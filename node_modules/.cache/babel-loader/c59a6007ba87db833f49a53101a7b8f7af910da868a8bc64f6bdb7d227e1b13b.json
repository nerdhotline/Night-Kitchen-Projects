{"ast":null,"code":"import { X as XSTATE_STOP, A as createActor } from '../../dist/raise-5ea71f04.development.esm.js';\nimport '../../dev/dist/xstate-dev.development.esm.js';\n\n/**\n * Represents an actor created by `fromTransition`.\n *\n * The type of `self` within the actor's logic.\n *\n * @example\n *\n * ```ts\n * import {\n *   fromTransition,\n *   createActor,\n *   type AnyActorSystem\n * } from 'xstate';\n *\n * //* The actor's stored context.\n * type Context = {\n *   // The current count.\n *   count: number;\n *   // The amount to increase `count` by.\n *   step: number;\n * };\n * // The events the actor receives.\n * type Event = { type: 'increment' };\n * // The actor's input.\n * type Input = { step?: number };\n *\n * // Actor logic that increments `count` by `step` when it receives an event of\n * // type `increment`.\n * const logic = fromTransition<Context, Event, AnyActorSystem, Input>(\n *   (state, event, actorScope) => {\n *     actorScope.self;\n *     //         ^? TransitionActorRef<Context, Event>\n *\n *     if (event.type === 'increment') {\n *       return {\n *         ...state,\n *         count: state.count + state.step\n *       };\n *     }\n *     return state;\n *   },\n *   ({ input, self }) => {\n *     self;\n *     // ^? TransitionActorRef<Context, Event>\n *\n *     return {\n *       count: 0,\n *       step: input.step ?? 1\n *     };\n *   }\n * );\n *\n * const actor = createActor(logic, { input: { step: 10 } });\n * //    ^? TransitionActorRef<Context, Event>\n * ```\n *\n * @see {@link fromTransition}\n */\n\n/**\n * Returns actor logic given a transition function and its initial state.\n *\n * A “transition function” is a function that takes the current `state` and\n * received `event` object as arguments, and returns the next state, similar to\n * a reducer.\n *\n * Actors created from transition logic (“transition actors”) can:\n *\n * - Receive events\n * - Emit snapshots of its state\n *\n * The transition function’s `state` is used as its transition actor’s\n * `context`.\n *\n * Note that the \"state\" for a transition function is provided by the initial\n * state argument, and is not the same as the State object of an actor or a\n * state within a machine configuration.\n *\n * @example\n *\n * ```ts\n * const transitionLogic = fromTransition(\n *   (state, event) => {\n *     if (event.type === 'increment') {\n *       return {\n *         ...state,\n *         count: state.count + 1\n *       };\n *     }\n *     return state;\n *   },\n *   { count: 0 }\n * );\n *\n * const transitionActor = createActor(transitionLogic);\n * transitionActor.subscribe((snapshot) => {\n *   console.log(snapshot);\n * });\n * transitionActor.start();\n * // => {\n * //   status: 'active',\n * //   context: { count: 0 },\n * //   ...\n * // }\n *\n * transitionActor.send({ type: 'increment' });\n * // => {\n * //   status: 'active',\n * //   context: { count: 1 },\n * //   ...\n * // }\n * ```\n *\n * @param transition The transition function used to describe the transition\n *   logic. It should return the next state given the current state and event.\n *   It receives the following arguments:\n *\n *   - `state` - the current state.\n *   - `event` - the received event.\n *   - `actorScope` - the actor scope object, with properties like `self` and\n *       `system`.\n *\n * @param initialContext The initial state of the transition function, either an\n *   object representing the state, or a function which returns a state object.\n *   If a function, it will receive as its only argument an object with the\n *   following properties:\n *\n *   - `input` - the `input` provided to its parent transition actor.\n *   - `self` - a reference to its parent transition actor.\n *\n * @returns Actor logic\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\n */\nfunction fromTransition(transition, initialContext) {\n  return {\n    config: transition,\n    transition: (snapshot, event, actorScope) => {\n      return {\n        ...snapshot,\n        context: transition(snapshot.context, event, actorScope)\n      };\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        context: typeof initialContext === 'function' ? initialContext({\n          input\n        }) : initialContext\n      };\n    },\n    getPersistedSnapshot: snapshot => snapshot,\n    restoreSnapshot: snapshot => snapshot\n  };\n}\nconst instanceStates = /* #__PURE__ */new WeakMap();\n\n/**\n * Represents an actor created by `fromCallback`.\n *\n * The type of `self` within the actor's logic.\n *\n * @example\n *\n * ```ts\n * import { fromCallback, createActor } from 'xstate';\n *\n * // The events the actor receives.\n * type Event = { type: 'someEvent' };\n * // The actor's input.\n * type Input = { name: string };\n *\n * // Actor logic that logs whenever it receives an event of type `someEvent`.\n * const logic = fromCallback<Event, Input>(({ self, input, receive }) => {\n *   self;\n *   // ^? CallbackActorRef<Event, Input>\n *\n *   receive((event) => {\n *     if (event.type === 'someEvent') {\n *       console.log(`${input.name}: received \"someEvent\" event`);\n *       // logs 'myActor: received \"someEvent\" event'\n *     }\n *   });\n * });\n *\n * const actor = createActor(logic, { input: { name: 'myActor' } });\n * //    ^? CallbackActorRef<Event, Input>\n * ```\n *\n * @see {@link fromCallback}\n */\n\n/**\n * An actor logic creator which returns callback logic as defined by a callback\n * function.\n *\n * @remarks\n * Useful for subscription-based or other free-form logic that can send events\n * back to the parent actor.\n *\n * Actors created from callback logic (“callback actors”) can:\n *\n * - Receive events via the `receive` function\n * - Send events to the parent actor via the `sendBack` function\n *\n * Callback actors are a bit different from other actors in that they:\n *\n * - Do not work with `onDone`\n * - Do not produce a snapshot using `.getSnapshot()`\n * - Do not emit values when used with `.subscribe()`\n * - Can not be stopped with `.stop()`\n *\n * @example\n *\n * ```typescript\n * const callbackLogic = fromCallback(({ sendBack, receive }) => {\n *   let lockStatus = 'unlocked';\n *\n *   const handler = (event) => {\n *     if (lockStatus === 'locked') {\n *       return;\n *     }\n *     sendBack(event);\n *   };\n *\n *   receive((event) => {\n *     if (event.type === 'lock') {\n *       lockStatus = 'locked';\n *     } else if (event.type === 'unlock') {\n *       lockStatus = 'unlocked';\n *     }\n *   });\n *\n *   document.body.addEventListener('click', handler);\n *\n *   return () => {\n *     document.body.removeEventListener('click', handler);\n *   };\n * });\n * ```\n *\n * @param callback - The callback function used to describe the callback logic\n *   The callback function is passed an object with the following properties:\n *\n *   - `receive` - A function that can send events back to the parent actor; the\n *       listener is then called whenever events are received by the callback\n *       actor\n *   - `sendBack` - A function that can send events back to the parent actor\n *   - `input` - Data that was provided to the callback actor\n *   - `self` - The parent actor of the callback actor\n *   - `system` - The actor system to which the callback actor belongs The callback\n *       function can (optionally) return a cleanup function, which is called\n *       when the actor is stopped.\n *\n * @returns Callback logic\n * @see {@link CallbackLogicFunction} for more information about the callback function and its object argument\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\n */\nfunction fromCallback(callback) {\n  const logic = {\n    config: callback,\n    start: (state, actorScope) => {\n      const {\n        self,\n        system,\n        emit\n      } = actorScope;\n      const callbackState = {\n        receivers: undefined,\n        dispose: undefined\n      };\n      instanceStates.set(self, callbackState);\n      callbackState.dispose = callback({\n        input: state.input,\n        system,\n        self,\n        sendBack: event => {\n          if (self.getSnapshot().status === 'stopped') {\n            return;\n          }\n          if (self._parent) {\n            system._relay(self, self._parent, event);\n          }\n        },\n        receive: listener => {\n          callbackState.receivers ??= new Set();\n          callbackState.receivers.add(listener);\n        },\n        emit\n      });\n    },\n    transition: (state, event, actorScope) => {\n      const callbackState = instanceStates.get(actorScope.self);\n      if (event.type === XSTATE_STOP) {\n        state = {\n          ...state,\n          status: 'stopped',\n          error: undefined\n        };\n        callbackState.dispose?.();\n        return state;\n      }\n      callbackState.receivers?.forEach(receiver => receiver(event));\n      return state;\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        input\n      };\n    },\n    getPersistedSnapshot: snapshot => snapshot,\n    restoreSnapshot: snapshot => snapshot\n  };\n  return logic;\n}\nconst XSTATE_OBSERVABLE_NEXT = 'xstate.observable.next';\nconst XSTATE_OBSERVABLE_ERROR = 'xstate.observable.error';\nconst XSTATE_OBSERVABLE_COMPLETE = 'xstate.observable.complete';\n\n/**\n * Represents an actor created by `fromObservable` or `fromEventObservable`.\n *\n * The type of `self` within the actor's logic.\n *\n * @example\n *\n * ```ts\n * import { fromObservable, createActor } from 'xstate';\n * import { interval } from 'rxjs';\n *\n * // The type of the value observed by the actor's logic.\n * type Context = number;\n * // The actor's input.\n * type Input = { period?: number };\n *\n * // Actor logic that observes a number incremented every `input.period`\n * // milliseconds (default: 1_000).\n * const logic = fromObservable<Context, Input>(({ input, self }) => {\n *   self;\n *   // ^? ObservableActorRef<Event, Input>\n *\n *   return interval(input.period ?? 1_000);\n * });\n *\n * const actor = createActor(logic, { input: { period: 2_000 } });\n * //    ^? ObservableActorRef<Event, Input>\n * ```\n *\n * @see {@link fromObservable}\n * @see {@link fromEventObservable}\n */\n\n/**\n * Observable actor logic is described by an observable stream of values. Actors\n * created from observable logic (“observable actors”) can:\n *\n * - Emit snapshots of the observable’s emitted value\n *\n * The observable’s emitted value is used as its observable actor’s `context`.\n *\n * Sending events to observable actors will have no effect.\n *\n * @example\n *\n * ```ts\n * import { fromObservable, createActor } from 'xstate';\n * import { interval } from 'rxjs';\n *\n * const logic = fromObservable((obj) => interval(1000));\n *\n * const actor = createActor(logic);\n *\n * actor.subscribe((snapshot) => {\n *   console.log(snapshot.context);\n * });\n *\n * actor.start();\n * // At every second:\n * // Logs 0\n * // Logs 1\n * // Logs 2\n * // ...\n * ```\n *\n * @param observableCreator A function that creates an observable. It receives\n *   one argument, an object with the following properties:\n *\n *   - `input` - Data that was provided to the observable actor\n *   - `self` - The parent actor\n *   - `system` - The actor system to which the observable actor belongs\n *\n *   It should return a {@link Subscribable}, which is compatible with an RxJS\n *   Observable, although RxJS is not required to create them.\n * @see {@link https://rxjs.dev} for documentation on RxJS Observable and observable creators.\n * @see {@link Subscribable} interface in XState, which is based on and compatible with RxJS Observable.\n */\nfunction fromObservable(observableCreator) {\n  // TODO: add event types\n  const logic = {\n    config: observableCreator,\n    transition: (snapshot, event) => {\n      if (snapshot.status !== 'active') {\n        return snapshot;\n      }\n      switch (event.type) {\n        case XSTATE_OBSERVABLE_NEXT:\n          {\n            const newSnapshot = {\n              ...snapshot,\n              context: event.data\n            };\n            return newSnapshot;\n          }\n        case XSTATE_OBSERVABLE_ERROR:\n          return {\n            ...snapshot,\n            status: 'error',\n            error: event.data,\n            input: undefined,\n            _subscription: undefined\n          };\n        case XSTATE_OBSERVABLE_COMPLETE:\n          return {\n            ...snapshot,\n            status: 'done',\n            input: undefined,\n            _subscription: undefined\n          };\n        case XSTATE_STOP:\n          snapshot._subscription.unsubscribe();\n          return {\n            ...snapshot,\n            status: 'stopped',\n            input: undefined,\n            _subscription: undefined\n          };\n        default:\n          return snapshot;\n      }\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        context: undefined,\n        input,\n        _subscription: undefined\n      };\n    },\n    start: (state, {\n      self,\n      system,\n      emit\n    }) => {\n      if (state.status === 'done') {\n        // Do not restart a completed observable\n        return;\n      }\n      state._subscription = observableCreator({\n        input: state.input,\n        system,\n        self,\n        emit\n      }).subscribe({\n        next: value => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_NEXT,\n            data: value\n          });\n        },\n        error: err => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_ERROR,\n            data: err\n          });\n        },\n        complete: () => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_COMPLETE\n          });\n        }\n      });\n    },\n    getPersistedSnapshot: ({\n      _subscription,\n      ...state\n    }) => state,\n    restoreSnapshot: state => ({\n      ...state,\n      _subscription: undefined\n    })\n  };\n  return logic;\n}\n\n/**\n * Creates event observable logic that listens to an observable that delivers\n * event objects.\n *\n * Event observable actor logic is described by an observable stream of\n * {@link https://stately.ai/docs/transitions#event-objects | event objects}.\n * Actors created from event observable logic (“event observable actors”) can:\n *\n * - Implicitly send events to its parent actor\n * - Emit snapshots of its emitted event objects\n *\n * Sending events to event observable actors will have no effect.\n *\n * @example\n *\n * ```ts\n * import {\n *   fromEventObservable,\n *   Subscribable,\n *   EventObject,\n *   createMachine,\n *   createActor\n * } from 'xstate';\n * import { fromEvent } from 'rxjs';\n *\n * const mouseClickLogic = fromEventObservable(\n *   () => fromEvent(document.body, 'click') as Subscribable<EventObject>\n * );\n *\n * const canvasMachine = createMachine({\n *   invoke: {\n *     // Will send mouse `click` events to the canvas actor\n *     src: mouseClickLogic\n *   }\n * });\n *\n * const canvasActor = createActor(canvasMachine);\n * canvasActor.start();\n * ```\n *\n * @param lazyObservable A function that creates an observable that delivers\n *   event objects. It receives one argument, an object with the following\n *   properties:\n *\n *   - `input` - Data that was provided to the event observable actor\n *   - `self` - The parent actor\n *   - `system` - The actor system to which the event observable actor belongs.\n *\n *   It should return a {@link Subscribable}, which is compatible with an RxJS\n *   Observable, although RxJS is not required to create them.\n */\nfunction fromEventObservable(lazyObservable) {\n  // TODO: event types\n  const logic = {\n    config: lazyObservable,\n    transition: (state, event) => {\n      if (state.status !== 'active') {\n        return state;\n      }\n      switch (event.type) {\n        case XSTATE_OBSERVABLE_ERROR:\n          return {\n            ...state,\n            status: 'error',\n            error: event.data,\n            input: undefined,\n            _subscription: undefined\n          };\n        case XSTATE_OBSERVABLE_COMPLETE:\n          return {\n            ...state,\n            status: 'done',\n            input: undefined,\n            _subscription: undefined\n          };\n        case XSTATE_STOP:\n          state._subscription.unsubscribe();\n          return {\n            ...state,\n            status: 'stopped',\n            input: undefined,\n            _subscription: undefined\n          };\n        default:\n          return state;\n      }\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        context: undefined,\n        input,\n        _subscription: undefined\n      };\n    },\n    start: (state, {\n      self,\n      system,\n      emit\n    }) => {\n      if (state.status === 'done') {\n        // Do not restart a completed observable\n        return;\n      }\n      state._subscription = lazyObservable({\n        input: state.input,\n        system,\n        self,\n        emit\n      }).subscribe({\n        next: value => {\n          if (self._parent) {\n            system._relay(self, self._parent, value);\n          }\n        },\n        error: err => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_ERROR,\n            data: err\n          });\n        },\n        complete: () => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_COMPLETE\n          });\n        }\n      });\n    },\n    getPersistedSnapshot: ({\n      _subscription,\n      ...snapshot\n    }) => snapshot,\n    restoreSnapshot: snapshot => ({\n      ...snapshot,\n      _subscription: undefined\n    })\n  };\n  return logic;\n}\nconst XSTATE_PROMISE_RESOLVE = 'xstate.promise.resolve';\nconst XSTATE_PROMISE_REJECT = 'xstate.promise.reject';\n\n/**\n * Represents an actor created by `fromPromise`.\n *\n * The type of `self` within the actor's logic.\n *\n * @example\n *\n * ```ts\n * import { fromPromise, createActor } from 'xstate';\n *\n * // The actor's resolved output\n * type Output = string;\n * // The actor's input.\n * type Input = { message: string };\n *\n * // Actor logic that fetches the url of an image of a cat saying `input.message`.\n * const logic = fromPromise<Output, Input>(async ({ input, self }) => {\n *   self;\n *   // ^? PromiseActorRef<Output, Input>\n *\n *   const data = await fetch(\n *     `https://cataas.com/cat/says/${input.message}`\n *   );\n *   const url = await data.json();\n *   return url;\n * });\n *\n * const actor = createActor(logic, { input: { message: 'hello world' } });\n * //    ^? PromiseActorRef<Output, Input>\n * ```\n *\n * @see {@link fromPromise}\n */\n\nconst controllerMap = new WeakMap();\n\n/**\n * An actor logic creator which returns promise logic as defined by an async\n * process that resolves or rejects after some time.\n *\n * Actors created from promise actor logic (“promise actors”) can:\n *\n * - Emit the resolved value of the promise\n * - Output the resolved value of the promise\n *\n * Sending events to promise actors will have no effect.\n *\n * @example\n *\n * ```ts\n * const promiseLogic = fromPromise(async () => {\n *   const result = await fetch('https://example.com/...').then((data) =>\n *     data.json()\n *   );\n *\n *   return result;\n * });\n *\n * const promiseActor = createActor(promiseLogic);\n * promiseActor.subscribe((snapshot) => {\n *   console.log(snapshot);\n * });\n * promiseActor.start();\n * // => {\n * //   output: undefined,\n * //   status: 'active'\n * //   ...\n * // }\n *\n * // After promise resolves\n * // => {\n * //   output: { ... },\n * //   status: 'done',\n * //   ...\n * // }\n * ```\n *\n * @param promiseCreator A function which returns a Promise, and accepts an\n *   object with the following properties:\n *\n *   - `input` - Data that was provided to the promise actor\n *   - `self` - The parent actor of the promise actor\n *   - `system` - The actor system to which the promise actor belongs\n *\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\n */\nfunction fromPromise(promiseCreator) {\n  const logic = {\n    config: promiseCreator,\n    transition: (state, event, scope) => {\n      if (state.status !== 'active') {\n        return state;\n      }\n      switch (event.type) {\n        case XSTATE_PROMISE_RESOLVE:\n          {\n            const resolvedValue = event.data;\n            return {\n              ...state,\n              status: 'done',\n              output: resolvedValue,\n              input: undefined\n            };\n          }\n        case XSTATE_PROMISE_REJECT:\n          return {\n            ...state,\n            status: 'error',\n            error: event.data,\n            input: undefined\n          };\n        case XSTATE_STOP:\n          {\n            controllerMap.get(scope.self)?.abort();\n            return {\n              ...state,\n              status: 'stopped',\n              input: undefined\n            };\n          }\n        default:\n          return state;\n      }\n    },\n    start: (state, {\n      self,\n      system,\n      emit\n    }) => {\n      // TODO: determine how to allow customizing this so that promises\n      // can be restarted if necessary\n      if (state.status !== 'active') {\n        return;\n      }\n      const controller = new AbortController();\n      controllerMap.set(self, controller);\n      const resolvedPromise = Promise.resolve(promiseCreator({\n        input: state.input,\n        system,\n        self,\n        signal: controller.signal,\n        emit\n      }));\n      resolvedPromise.then(response => {\n        if (self.getSnapshot().status !== 'active') {\n          return;\n        }\n        controllerMap.delete(self);\n        system._relay(self, self, {\n          type: XSTATE_PROMISE_RESOLVE,\n          data: response\n        });\n      }, errorData => {\n        if (self.getSnapshot().status !== 'active') {\n          return;\n        }\n        controllerMap.delete(self);\n        system._relay(self, self, {\n          type: XSTATE_PROMISE_REJECT,\n          data: errorData\n        });\n      });\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        input\n      };\n    },\n    getPersistedSnapshot: snapshot => snapshot,\n    restoreSnapshot: snapshot => snapshot\n  };\n  return logic;\n}\nconst emptyLogic = fromTransition(_ => undefined, undefined);\nfunction createEmptyActor() {\n  return createActor(emptyLogic);\n}\nexport { createEmptyActor, fromCallback, fromEventObservable, fromObservable, fromPromise, fromTransition };","map":{"version":3,"names":["X","XSTATE_STOP","A","createActor","fromTransition","transition","initialContext","config","snapshot","event","actorScope","context","getInitialSnapshot","_","input","status","output","undefined","error","getPersistedSnapshot","restoreSnapshot","instanceStates","WeakMap","fromCallback","callback","logic","start","state","self","system","emit","callbackState","receivers","dispose","set","sendBack","getSnapshot","_parent","_relay","receive","listener","Set","add","get","type","forEach","receiver","XSTATE_OBSERVABLE_NEXT","XSTATE_OBSERVABLE_ERROR","XSTATE_OBSERVABLE_COMPLETE","fromObservable","observableCreator","newSnapshot","data","_subscription","unsubscribe","subscribe","next","value","err","complete","fromEventObservable","lazyObservable","XSTATE_PROMISE_RESOLVE","XSTATE_PROMISE_REJECT","controllerMap","fromPromise","promiseCreator","scope","resolvedValue","abort","controller","AbortController","resolvedPromise","Promise","resolve","signal","then","response","delete","errorData","emptyLogic","createEmptyActor"],"sources":["C:/Users/kenne/OneDrive/Documents/GitHub/claw-and-order/Night-Kitchen-Projects/node_modules/xstate/actors/dist/xstate-actors.development.esm.js"],"sourcesContent":["import { X as XSTATE_STOP, A as createActor } from '../../dist/raise-5ea71f04.development.esm.js';\nimport '../../dev/dist/xstate-dev.development.esm.js';\n\n/**\n * Represents an actor created by `fromTransition`.\n *\n * The type of `self` within the actor's logic.\n *\n * @example\n *\n * ```ts\n * import {\n *   fromTransition,\n *   createActor,\n *   type AnyActorSystem\n * } from 'xstate';\n *\n * //* The actor's stored context.\n * type Context = {\n *   // The current count.\n *   count: number;\n *   // The amount to increase `count` by.\n *   step: number;\n * };\n * // The events the actor receives.\n * type Event = { type: 'increment' };\n * // The actor's input.\n * type Input = { step?: number };\n *\n * // Actor logic that increments `count` by `step` when it receives an event of\n * // type `increment`.\n * const logic = fromTransition<Context, Event, AnyActorSystem, Input>(\n *   (state, event, actorScope) => {\n *     actorScope.self;\n *     //         ^? TransitionActorRef<Context, Event>\n *\n *     if (event.type === 'increment') {\n *       return {\n *         ...state,\n *         count: state.count + state.step\n *       };\n *     }\n *     return state;\n *   },\n *   ({ input, self }) => {\n *     self;\n *     // ^? TransitionActorRef<Context, Event>\n *\n *     return {\n *       count: 0,\n *       step: input.step ?? 1\n *     };\n *   }\n * );\n *\n * const actor = createActor(logic, { input: { step: 10 } });\n * //    ^? TransitionActorRef<Context, Event>\n * ```\n *\n * @see {@link fromTransition}\n */\n\n/**\n * Returns actor logic given a transition function and its initial state.\n *\n * A “transition function” is a function that takes the current `state` and\n * received `event` object as arguments, and returns the next state, similar to\n * a reducer.\n *\n * Actors created from transition logic (“transition actors”) can:\n *\n * - Receive events\n * - Emit snapshots of its state\n *\n * The transition function’s `state` is used as its transition actor’s\n * `context`.\n *\n * Note that the \"state\" for a transition function is provided by the initial\n * state argument, and is not the same as the State object of an actor or a\n * state within a machine configuration.\n *\n * @example\n *\n * ```ts\n * const transitionLogic = fromTransition(\n *   (state, event) => {\n *     if (event.type === 'increment') {\n *       return {\n *         ...state,\n *         count: state.count + 1\n *       };\n *     }\n *     return state;\n *   },\n *   { count: 0 }\n * );\n *\n * const transitionActor = createActor(transitionLogic);\n * transitionActor.subscribe((snapshot) => {\n *   console.log(snapshot);\n * });\n * transitionActor.start();\n * // => {\n * //   status: 'active',\n * //   context: { count: 0 },\n * //   ...\n * // }\n *\n * transitionActor.send({ type: 'increment' });\n * // => {\n * //   status: 'active',\n * //   context: { count: 1 },\n * //   ...\n * // }\n * ```\n *\n * @param transition The transition function used to describe the transition\n *   logic. It should return the next state given the current state and event.\n *   It receives the following arguments:\n *\n *   - `state` - the current state.\n *   - `event` - the received event.\n *   - `actorScope` - the actor scope object, with properties like `self` and\n *       `system`.\n *\n * @param initialContext The initial state of the transition function, either an\n *   object representing the state, or a function which returns a state object.\n *   If a function, it will receive as its only argument an object with the\n *   following properties:\n *\n *   - `input` - the `input` provided to its parent transition actor.\n *   - `self` - a reference to its parent transition actor.\n *\n * @returns Actor logic\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\n */\nfunction fromTransition(transition, initialContext) {\n  return {\n    config: transition,\n    transition: (snapshot, event, actorScope) => {\n      return {\n        ...snapshot,\n        context: transition(snapshot.context, event, actorScope)\n      };\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        context: typeof initialContext === 'function' ? initialContext({\n          input\n        }) : initialContext\n      };\n    },\n    getPersistedSnapshot: snapshot => snapshot,\n    restoreSnapshot: snapshot => snapshot\n  };\n}\n\nconst instanceStates = /* #__PURE__ */new WeakMap();\n\n/**\n * Represents an actor created by `fromCallback`.\n *\n * The type of `self` within the actor's logic.\n *\n * @example\n *\n * ```ts\n * import { fromCallback, createActor } from 'xstate';\n *\n * // The events the actor receives.\n * type Event = { type: 'someEvent' };\n * // The actor's input.\n * type Input = { name: string };\n *\n * // Actor logic that logs whenever it receives an event of type `someEvent`.\n * const logic = fromCallback<Event, Input>(({ self, input, receive }) => {\n *   self;\n *   // ^? CallbackActorRef<Event, Input>\n *\n *   receive((event) => {\n *     if (event.type === 'someEvent') {\n *       console.log(`${input.name}: received \"someEvent\" event`);\n *       // logs 'myActor: received \"someEvent\" event'\n *     }\n *   });\n * });\n *\n * const actor = createActor(logic, { input: { name: 'myActor' } });\n * //    ^? CallbackActorRef<Event, Input>\n * ```\n *\n * @see {@link fromCallback}\n */\n\n/**\n * An actor logic creator which returns callback logic as defined by a callback\n * function.\n *\n * @remarks\n * Useful for subscription-based or other free-form logic that can send events\n * back to the parent actor.\n *\n * Actors created from callback logic (“callback actors”) can:\n *\n * - Receive events via the `receive` function\n * - Send events to the parent actor via the `sendBack` function\n *\n * Callback actors are a bit different from other actors in that they:\n *\n * - Do not work with `onDone`\n * - Do not produce a snapshot using `.getSnapshot()`\n * - Do not emit values when used with `.subscribe()`\n * - Can not be stopped with `.stop()`\n *\n * @example\n *\n * ```typescript\n * const callbackLogic = fromCallback(({ sendBack, receive }) => {\n *   let lockStatus = 'unlocked';\n *\n *   const handler = (event) => {\n *     if (lockStatus === 'locked') {\n *       return;\n *     }\n *     sendBack(event);\n *   };\n *\n *   receive((event) => {\n *     if (event.type === 'lock') {\n *       lockStatus = 'locked';\n *     } else if (event.type === 'unlock') {\n *       lockStatus = 'unlocked';\n *     }\n *   });\n *\n *   document.body.addEventListener('click', handler);\n *\n *   return () => {\n *     document.body.removeEventListener('click', handler);\n *   };\n * });\n * ```\n *\n * @param callback - The callback function used to describe the callback logic\n *   The callback function is passed an object with the following properties:\n *\n *   - `receive` - A function that can send events back to the parent actor; the\n *       listener is then called whenever events are received by the callback\n *       actor\n *   - `sendBack` - A function that can send events back to the parent actor\n *   - `input` - Data that was provided to the callback actor\n *   - `self` - The parent actor of the callback actor\n *   - `system` - The actor system to which the callback actor belongs The callback\n *       function can (optionally) return a cleanup function, which is called\n *       when the actor is stopped.\n *\n * @returns Callback logic\n * @see {@link CallbackLogicFunction} for more information about the callback function and its object argument\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\n */\nfunction fromCallback(callback) {\n  const logic = {\n    config: callback,\n    start: (state, actorScope) => {\n      const {\n        self,\n        system,\n        emit\n      } = actorScope;\n      const callbackState = {\n        receivers: undefined,\n        dispose: undefined\n      };\n      instanceStates.set(self, callbackState);\n      callbackState.dispose = callback({\n        input: state.input,\n        system,\n        self,\n        sendBack: event => {\n          if (self.getSnapshot().status === 'stopped') {\n            return;\n          }\n          if (self._parent) {\n            system._relay(self, self._parent, event);\n          }\n        },\n        receive: listener => {\n          callbackState.receivers ??= new Set();\n          callbackState.receivers.add(listener);\n        },\n        emit\n      });\n    },\n    transition: (state, event, actorScope) => {\n      const callbackState = instanceStates.get(actorScope.self);\n      if (event.type === XSTATE_STOP) {\n        state = {\n          ...state,\n          status: 'stopped',\n          error: undefined\n        };\n        callbackState.dispose?.();\n        return state;\n      }\n      callbackState.receivers?.forEach(receiver => receiver(event));\n      return state;\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        input\n      };\n    },\n    getPersistedSnapshot: snapshot => snapshot,\n    restoreSnapshot: snapshot => snapshot\n  };\n  return logic;\n}\n\nconst XSTATE_OBSERVABLE_NEXT = 'xstate.observable.next';\nconst XSTATE_OBSERVABLE_ERROR = 'xstate.observable.error';\nconst XSTATE_OBSERVABLE_COMPLETE = 'xstate.observable.complete';\n\n/**\n * Represents an actor created by `fromObservable` or `fromEventObservable`.\n *\n * The type of `self` within the actor's logic.\n *\n * @example\n *\n * ```ts\n * import { fromObservable, createActor } from 'xstate';\n * import { interval } from 'rxjs';\n *\n * // The type of the value observed by the actor's logic.\n * type Context = number;\n * // The actor's input.\n * type Input = { period?: number };\n *\n * // Actor logic that observes a number incremented every `input.period`\n * // milliseconds (default: 1_000).\n * const logic = fromObservable<Context, Input>(({ input, self }) => {\n *   self;\n *   // ^? ObservableActorRef<Event, Input>\n *\n *   return interval(input.period ?? 1_000);\n * });\n *\n * const actor = createActor(logic, { input: { period: 2_000 } });\n * //    ^? ObservableActorRef<Event, Input>\n * ```\n *\n * @see {@link fromObservable}\n * @see {@link fromEventObservable}\n */\n\n/**\n * Observable actor logic is described by an observable stream of values. Actors\n * created from observable logic (“observable actors”) can:\n *\n * - Emit snapshots of the observable’s emitted value\n *\n * The observable’s emitted value is used as its observable actor’s `context`.\n *\n * Sending events to observable actors will have no effect.\n *\n * @example\n *\n * ```ts\n * import { fromObservable, createActor } from 'xstate';\n * import { interval } from 'rxjs';\n *\n * const logic = fromObservable((obj) => interval(1000));\n *\n * const actor = createActor(logic);\n *\n * actor.subscribe((snapshot) => {\n *   console.log(snapshot.context);\n * });\n *\n * actor.start();\n * // At every second:\n * // Logs 0\n * // Logs 1\n * // Logs 2\n * // ...\n * ```\n *\n * @param observableCreator A function that creates an observable. It receives\n *   one argument, an object with the following properties:\n *\n *   - `input` - Data that was provided to the observable actor\n *   - `self` - The parent actor\n *   - `system` - The actor system to which the observable actor belongs\n *\n *   It should return a {@link Subscribable}, which is compatible with an RxJS\n *   Observable, although RxJS is not required to create them.\n * @see {@link https://rxjs.dev} for documentation on RxJS Observable and observable creators.\n * @see {@link Subscribable} interface in XState, which is based on and compatible with RxJS Observable.\n */\nfunction fromObservable(observableCreator) {\n  // TODO: add event types\n  const logic = {\n    config: observableCreator,\n    transition: (snapshot, event) => {\n      if (snapshot.status !== 'active') {\n        return snapshot;\n      }\n      switch (event.type) {\n        case XSTATE_OBSERVABLE_NEXT:\n          {\n            const newSnapshot = {\n              ...snapshot,\n              context: event.data\n            };\n            return newSnapshot;\n          }\n        case XSTATE_OBSERVABLE_ERROR:\n          return {\n            ...snapshot,\n            status: 'error',\n            error: event.data,\n            input: undefined,\n            _subscription: undefined\n          };\n        case XSTATE_OBSERVABLE_COMPLETE:\n          return {\n            ...snapshot,\n            status: 'done',\n            input: undefined,\n            _subscription: undefined\n          };\n        case XSTATE_STOP:\n          snapshot._subscription.unsubscribe();\n          return {\n            ...snapshot,\n            status: 'stopped',\n            input: undefined,\n            _subscription: undefined\n          };\n        default:\n          return snapshot;\n      }\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        context: undefined,\n        input,\n        _subscription: undefined\n      };\n    },\n    start: (state, {\n      self,\n      system,\n      emit\n    }) => {\n      if (state.status === 'done') {\n        // Do not restart a completed observable\n        return;\n      }\n      state._subscription = observableCreator({\n        input: state.input,\n        system,\n        self,\n        emit\n      }).subscribe({\n        next: value => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_NEXT,\n            data: value\n          });\n        },\n        error: err => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_ERROR,\n            data: err\n          });\n        },\n        complete: () => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_COMPLETE\n          });\n        }\n      });\n    },\n    getPersistedSnapshot: ({\n      _subscription,\n      ...state\n    }) => state,\n    restoreSnapshot: state => ({\n      ...state,\n      _subscription: undefined\n    })\n  };\n  return logic;\n}\n\n/**\n * Creates event observable logic that listens to an observable that delivers\n * event objects.\n *\n * Event observable actor logic is described by an observable stream of\n * {@link https://stately.ai/docs/transitions#event-objects | event objects}.\n * Actors created from event observable logic (“event observable actors”) can:\n *\n * - Implicitly send events to its parent actor\n * - Emit snapshots of its emitted event objects\n *\n * Sending events to event observable actors will have no effect.\n *\n * @example\n *\n * ```ts\n * import {\n *   fromEventObservable,\n *   Subscribable,\n *   EventObject,\n *   createMachine,\n *   createActor\n * } from 'xstate';\n * import { fromEvent } from 'rxjs';\n *\n * const mouseClickLogic = fromEventObservable(\n *   () => fromEvent(document.body, 'click') as Subscribable<EventObject>\n * );\n *\n * const canvasMachine = createMachine({\n *   invoke: {\n *     // Will send mouse `click` events to the canvas actor\n *     src: mouseClickLogic\n *   }\n * });\n *\n * const canvasActor = createActor(canvasMachine);\n * canvasActor.start();\n * ```\n *\n * @param lazyObservable A function that creates an observable that delivers\n *   event objects. It receives one argument, an object with the following\n *   properties:\n *\n *   - `input` - Data that was provided to the event observable actor\n *   - `self` - The parent actor\n *   - `system` - The actor system to which the event observable actor belongs.\n *\n *   It should return a {@link Subscribable}, which is compatible with an RxJS\n *   Observable, although RxJS is not required to create them.\n */\nfunction fromEventObservable(lazyObservable) {\n  // TODO: event types\n  const logic = {\n    config: lazyObservable,\n    transition: (state, event) => {\n      if (state.status !== 'active') {\n        return state;\n      }\n      switch (event.type) {\n        case XSTATE_OBSERVABLE_ERROR:\n          return {\n            ...state,\n            status: 'error',\n            error: event.data,\n            input: undefined,\n            _subscription: undefined\n          };\n        case XSTATE_OBSERVABLE_COMPLETE:\n          return {\n            ...state,\n            status: 'done',\n            input: undefined,\n            _subscription: undefined\n          };\n        case XSTATE_STOP:\n          state._subscription.unsubscribe();\n          return {\n            ...state,\n            status: 'stopped',\n            input: undefined,\n            _subscription: undefined\n          };\n        default:\n          return state;\n      }\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        context: undefined,\n        input,\n        _subscription: undefined\n      };\n    },\n    start: (state, {\n      self,\n      system,\n      emit\n    }) => {\n      if (state.status === 'done') {\n        // Do not restart a completed observable\n        return;\n      }\n      state._subscription = lazyObservable({\n        input: state.input,\n        system,\n        self,\n        emit\n      }).subscribe({\n        next: value => {\n          if (self._parent) {\n            system._relay(self, self._parent, value);\n          }\n        },\n        error: err => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_ERROR,\n            data: err\n          });\n        },\n        complete: () => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_COMPLETE\n          });\n        }\n      });\n    },\n    getPersistedSnapshot: ({\n      _subscription,\n      ...snapshot\n    }) => snapshot,\n    restoreSnapshot: snapshot => ({\n      ...snapshot,\n      _subscription: undefined\n    })\n  };\n  return logic;\n}\n\nconst XSTATE_PROMISE_RESOLVE = 'xstate.promise.resolve';\nconst XSTATE_PROMISE_REJECT = 'xstate.promise.reject';\n\n/**\n * Represents an actor created by `fromPromise`.\n *\n * The type of `self` within the actor's logic.\n *\n * @example\n *\n * ```ts\n * import { fromPromise, createActor } from 'xstate';\n *\n * // The actor's resolved output\n * type Output = string;\n * // The actor's input.\n * type Input = { message: string };\n *\n * // Actor logic that fetches the url of an image of a cat saying `input.message`.\n * const logic = fromPromise<Output, Input>(async ({ input, self }) => {\n *   self;\n *   // ^? PromiseActorRef<Output, Input>\n *\n *   const data = await fetch(\n *     `https://cataas.com/cat/says/${input.message}`\n *   );\n *   const url = await data.json();\n *   return url;\n * });\n *\n * const actor = createActor(logic, { input: { message: 'hello world' } });\n * //    ^? PromiseActorRef<Output, Input>\n * ```\n *\n * @see {@link fromPromise}\n */\n\nconst controllerMap = new WeakMap();\n\n/**\n * An actor logic creator which returns promise logic as defined by an async\n * process that resolves or rejects after some time.\n *\n * Actors created from promise actor logic (“promise actors”) can:\n *\n * - Emit the resolved value of the promise\n * - Output the resolved value of the promise\n *\n * Sending events to promise actors will have no effect.\n *\n * @example\n *\n * ```ts\n * const promiseLogic = fromPromise(async () => {\n *   const result = await fetch('https://example.com/...').then((data) =>\n *     data.json()\n *   );\n *\n *   return result;\n * });\n *\n * const promiseActor = createActor(promiseLogic);\n * promiseActor.subscribe((snapshot) => {\n *   console.log(snapshot);\n * });\n * promiseActor.start();\n * // => {\n * //   output: undefined,\n * //   status: 'active'\n * //   ...\n * // }\n *\n * // After promise resolves\n * // => {\n * //   output: { ... },\n * //   status: 'done',\n * //   ...\n * // }\n * ```\n *\n * @param promiseCreator A function which returns a Promise, and accepts an\n *   object with the following properties:\n *\n *   - `input` - Data that was provided to the promise actor\n *   - `self` - The parent actor of the promise actor\n *   - `system` - The actor system to which the promise actor belongs\n *\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\n */\nfunction fromPromise(promiseCreator) {\n  const logic = {\n    config: promiseCreator,\n    transition: (state, event, scope) => {\n      if (state.status !== 'active') {\n        return state;\n      }\n      switch (event.type) {\n        case XSTATE_PROMISE_RESOLVE:\n          {\n            const resolvedValue = event.data;\n            return {\n              ...state,\n              status: 'done',\n              output: resolvedValue,\n              input: undefined\n            };\n          }\n        case XSTATE_PROMISE_REJECT:\n          return {\n            ...state,\n            status: 'error',\n            error: event.data,\n            input: undefined\n          };\n        case XSTATE_STOP:\n          {\n            controllerMap.get(scope.self)?.abort();\n            return {\n              ...state,\n              status: 'stopped',\n              input: undefined\n            };\n          }\n        default:\n          return state;\n      }\n    },\n    start: (state, {\n      self,\n      system,\n      emit\n    }) => {\n      // TODO: determine how to allow customizing this so that promises\n      // can be restarted if necessary\n      if (state.status !== 'active') {\n        return;\n      }\n      const controller = new AbortController();\n      controllerMap.set(self, controller);\n      const resolvedPromise = Promise.resolve(promiseCreator({\n        input: state.input,\n        system,\n        self,\n        signal: controller.signal,\n        emit\n      }));\n      resolvedPromise.then(response => {\n        if (self.getSnapshot().status !== 'active') {\n          return;\n        }\n        controllerMap.delete(self);\n        system._relay(self, self, {\n          type: XSTATE_PROMISE_RESOLVE,\n          data: response\n        });\n      }, errorData => {\n        if (self.getSnapshot().status !== 'active') {\n          return;\n        }\n        controllerMap.delete(self);\n        system._relay(self, self, {\n          type: XSTATE_PROMISE_REJECT,\n          data: errorData\n        });\n      });\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        input\n      };\n    },\n    getPersistedSnapshot: snapshot => snapshot,\n    restoreSnapshot: snapshot => snapshot\n  };\n  return logic;\n}\n\nconst emptyLogic = fromTransition(_ => undefined, undefined);\nfunction createEmptyActor() {\n  return createActor(emptyLogic);\n}\n\nexport { createEmptyActor, fromCallback, fromEventObservable, fromObservable, fromPromise, fromTransition };\n"],"mappings":"AAAA,SAASA,CAAC,IAAIC,WAAW,EAAEC,CAAC,IAAIC,WAAW,QAAQ,8CAA8C;AACjG,OAAO,8CAA8C;;AAErD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,cAAcA,CAACC,UAAU,EAAEC,cAAc,EAAE;EAClD,OAAO;IACLC,MAAM,EAAEF,UAAU;IAClBA,UAAU,EAAEA,CAACG,QAAQ,EAAEC,KAAK,EAAEC,UAAU,KAAK;MAC3C,OAAO;QACL,GAAGF,QAAQ;QACXG,OAAO,EAAEN,UAAU,CAACG,QAAQ,CAACG,OAAO,EAAEF,KAAK,EAAEC,UAAU;MACzD,CAAC;IACH,CAAC;IACDE,kBAAkB,EAAEA,CAACC,CAAC,EAAEC,KAAK,KAAK;MAChC,OAAO;QACLC,MAAM,EAAE,QAAQ;QAChBC,MAAM,EAAEC,SAAS;QACjBC,KAAK,EAAED,SAAS;QAChBN,OAAO,EAAE,OAAOL,cAAc,KAAK,UAAU,GAAGA,cAAc,CAAC;UAC7DQ;QACF,CAAC,CAAC,GAAGR;MACP,CAAC;IACH,CAAC;IACDa,oBAAoB,EAAEX,QAAQ,IAAIA,QAAQ;IAC1CY,eAAe,EAAEZ,QAAQ,IAAIA;EAC/B,CAAC;AACH;AAEA,MAAMa,cAAc,GAAG,eAAe,IAAIC,OAAO,CAAC,CAAC;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,YAAYA,CAACC,QAAQ,EAAE;EAC9B,MAAMC,KAAK,GAAG;IACZlB,MAAM,EAAEiB,QAAQ;IAChBE,KAAK,EAAEA,CAACC,KAAK,EAAEjB,UAAU,KAAK;MAC5B,MAAM;QACJkB,IAAI;QACJC,MAAM;QACNC;MACF,CAAC,GAAGpB,UAAU;MACd,MAAMqB,aAAa,GAAG;QACpBC,SAAS,EAAEf,SAAS;QACpBgB,OAAO,EAAEhB;MACX,CAAC;MACDI,cAAc,CAACa,GAAG,CAACN,IAAI,EAAEG,aAAa,CAAC;MACvCA,aAAa,CAACE,OAAO,GAAGT,QAAQ,CAAC;QAC/BV,KAAK,EAAEa,KAAK,CAACb,KAAK;QAClBe,MAAM;QACND,IAAI;QACJO,QAAQ,EAAE1B,KAAK,IAAI;UACjB,IAAImB,IAAI,CAACQ,WAAW,CAAC,CAAC,CAACrB,MAAM,KAAK,SAAS,EAAE;YAC3C;UACF;UACA,IAAIa,IAAI,CAACS,OAAO,EAAE;YAChBR,MAAM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hBR,MAAM,CAACS,MAAM,CAACV,IAAI,EAAEA,IAAI,CAACS,OAAO,EAAEqB,KAAK,CAAC;UAC1C;QACF,CAAC;QACDxC,KAAK,EAAEyC,GAAG,IAAI;UACZ9B,MAAM,CAACS,MAAM,CAACV,IAAI,EAAEA,IAAI,EAAE;YACxBgB,IAAI,EAAEI,uBAAuB;YAC7BK,IAAI,EAAEM;UACR,CAAC,CAAC;QACJ,CAAC;QACDC,QAAQ,EAAEA,CAAA,KAAM;UACd/B,MAAM,CAACS,MAAM,CAACV,IAAI,EAAEA,IAAI,EAAE;YACxBgB,IAAI,EAAEK;UACR,CAAC,CAAC;QACJ;MACF,CAAC,CAAC;IACJ,CAAC;IACD9B,oBAAoB,EAAEA,CAAC;MACrBmC,aAAa;MACb,GAAG9C;IACL,CAAC,KAAKA,QAAQ;IACdY,eAAe,EAAEZ,QAAQ,KAAK;MAC5B,GAAGA,QAAQ;MACX8C,aAAa,EAAErC;IACjB,CAAC;EACH,CAAC;EACD,OAAOQ,KAAK;AACd;AAEA,MAAMsC,sBAAsB,GAAG,wBAAwB;AACvD,MAAMC,qBAAqB,GAAG,uBAAuB;;AAErD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMC,aAAa,GAAG,IAAI3C,OAAO,CAAC,CAAC;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS4C,WAAWA,CAACC,cAAc,EAAE;EACnC,MAAM1C,KAAK,GAAG;IACZlB,MAAM,EAAE4D,cAAc;IACtB9D,UAAU,EAAEA,CAACsB,KAAK,EAAElB,KAAK,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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}