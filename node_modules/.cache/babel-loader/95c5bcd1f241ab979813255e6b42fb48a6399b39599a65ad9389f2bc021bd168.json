{"ast":null,"code":"import { X as XSTATE_STOP, A as createActor } from '../../dist/raise-5ea71f04.development.esm.js';\nimport '../../dev/dist/xstate-dev.development.esm.js';\n\n/**\r\n * Represents an actor created by `fromTransition`.\r\n *\r\n * The type of `self` within the actor's logic.\r\n *\r\n * @example\r\n *\r\n * ```ts\r\n * import {\r\n *   fromTransition,\r\n *   createActor,\r\n *   type AnyActorSystem\r\n * } from 'xstate';\r\n *\r\n * //* The actor's stored context.\r\n * type Context = {\r\n *   // The current count.\r\n *   count: number;\r\n *   // The amount to increase `count` by.\r\n *   step: number;\r\n * };\r\n * // The events the actor receives.\r\n * type Event = { type: 'increment' };\r\n * // The actor's input.\r\n * type Input = { step?: number };\r\n *\r\n * // Actor logic that increments `count` by `step` when it receives an event of\r\n * // type `increment`.\r\n * const logic = fromTransition<Context, Event, AnyActorSystem, Input>(\r\n *   (state, event, actorScope) => {\r\n *     actorScope.self;\r\n *     //         ^? TransitionActorRef<Context, Event>\r\n *\r\n *     if (event.type === 'increment') {\r\n *       return {\r\n *         ...state,\r\n *         count: state.count + state.step\r\n *       };\r\n *     }\r\n *     return state;\r\n *   },\r\n *   ({ input, self }) => {\r\n *     self;\r\n *     // ^? TransitionActorRef<Context, Event>\r\n *\r\n *     return {\r\n *       count: 0,\r\n *       step: input.step ?? 1\r\n *     };\r\n *   }\r\n * );\r\n *\r\n * const actor = createActor(logic, { input: { step: 10 } });\r\n * //    ^? TransitionActorRef<Context, Event>\r\n * ```\r\n *\r\n * @see {@link fromTransition}\r\n */\n\n/**\r\n * Returns actor logic given a transition function and its initial state.\r\n *\r\n * A “transition function” is a function that takes the current `state` and\r\n * received `event` object as arguments, and returns the next state, similar to\r\n * a reducer.\r\n *\r\n * Actors created from transition logic (“transition actors”) can:\r\n *\r\n * - Receive events\r\n * - Emit snapshots of its state\r\n *\r\n * The transition function’s `state` is used as its transition actor’s\r\n * `context`.\r\n *\r\n * Note that the \"state\" for a transition function is provided by the initial\r\n * state argument, and is not the same as the State object of an actor or a\r\n * state within a machine configuration.\r\n *\r\n * @example\r\n *\r\n * ```ts\r\n * const transitionLogic = fromTransition(\r\n *   (state, event) => {\r\n *     if (event.type === 'increment') {\r\n *       return {\r\n *         ...state,\r\n *         count: state.count + 1\r\n *       };\r\n *     }\r\n *     return state;\r\n *   },\r\n *   { count: 0 }\r\n * );\r\n *\r\n * const transitionActor = createActor(transitionLogic);\r\n * transitionActor.subscribe((snapshot) => {\r\n *   console.log(snapshot);\r\n * });\r\n * transitionActor.start();\r\n * // => {\r\n * //   status: 'active',\r\n * //   context: { count: 0 },\r\n * //   ...\r\n * // }\r\n *\r\n * transitionActor.send({ type: 'increment' });\r\n * // => {\r\n * //   status: 'active',\r\n * //   context: { count: 1 },\r\n * //   ...\r\n * // }\r\n * ```\r\n *\r\n * @param transition The transition function used to describe the transition\r\n *   logic. It should return the next state given the current state and event.\r\n *   It receives the following arguments:\r\n *\r\n *   - `state` - the current state.\r\n *   - `event` - the received event.\r\n *   - `actorScope` - the actor scope object, with properties like `self` and\r\n *       `system`.\r\n *\r\n * @param initialContext The initial state of the transition function, either an\r\n *   object representing the state, or a function which returns a state object.\r\n *   If a function, it will receive as its only argument an object with the\r\n *   following properties:\r\n *\r\n *   - `input` - the `input` provided to its parent transition actor.\r\n *   - `self` - a reference to its parent transition actor.\r\n *\r\n * @returns Actor logic\r\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\r\n */\nfunction fromTransition(transition, initialContext) {\n  return {\n    config: transition,\n    transition: (snapshot, event, actorScope) => {\n      return {\n        ...snapshot,\n        context: transition(snapshot.context, event, actorScope)\n      };\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        context: typeof initialContext === 'function' ? initialContext({\n          input\n        }) : initialContext\n      };\n    },\n    getPersistedSnapshot: snapshot => snapshot,\n    restoreSnapshot: snapshot => snapshot\n  };\n}\nconst instanceStates = /* #__PURE__ */new WeakMap();\n\n/**\r\n * Represents an actor created by `fromCallback`.\r\n *\r\n * The type of `self` within the actor's logic.\r\n *\r\n * @example\r\n *\r\n * ```ts\r\n * import { fromCallback, createActor } from 'xstate';\r\n *\r\n * // The events the actor receives.\r\n * type Event = { type: 'someEvent' };\r\n * // The actor's input.\r\n * type Input = { name: string };\r\n *\r\n * // Actor logic that logs whenever it receives an event of type `someEvent`.\r\n * const logic = fromCallback<Event, Input>(({ self, input, receive }) => {\r\n *   self;\r\n *   // ^? CallbackActorRef<Event, Input>\r\n *\r\n *   receive((event) => {\r\n *     if (event.type === 'someEvent') {\r\n *       console.log(`${input.name}: received \"someEvent\" event`);\r\n *       // logs 'myActor: received \"someEvent\" event'\r\n *     }\r\n *   });\r\n * });\r\n *\r\n * const actor = createActor(logic, { input: { name: 'myActor' } });\r\n * //    ^? CallbackActorRef<Event, Input>\r\n * ```\r\n *\r\n * @see {@link fromCallback}\r\n */\n\n/**\r\n * An actor logic creator which returns callback logic as defined by a callback\r\n * function.\r\n *\r\n * @remarks\r\n * Useful for subscription-based or other free-form logic that can send events\r\n * back to the parent actor.\r\n *\r\n * Actors created from callback logic (“callback actors”) can:\r\n *\r\n * - Receive events via the `receive` function\r\n * - Send events to the parent actor via the `sendBack` function\r\n *\r\n * Callback actors are a bit different from other actors in that they:\r\n *\r\n * - Do not work with `onDone`\r\n * - Do not produce a snapshot using `.getSnapshot()`\r\n * - Do not emit values when used with `.subscribe()`\r\n * - Can not be stopped with `.stop()`\r\n *\r\n * @example\r\n *\r\n * ```typescript\r\n * const callbackLogic = fromCallback(({ sendBack, receive }) => {\r\n *   let lockStatus = 'unlocked';\r\n *\r\n *   const handler = (event) => {\r\n *     if (lockStatus === 'locked') {\r\n *       return;\r\n *     }\r\n *     sendBack(event);\r\n *   };\r\n *\r\n *   receive((event) => {\r\n *     if (event.type === 'lock') {\r\n *       lockStatus = 'locked';\r\n *     } else if (event.type === 'unlock') {\r\n *       lockStatus = 'unlocked';\r\n *     }\r\n *   });\r\n *\r\n *   document.body.addEventListener('click', handler);\r\n *\r\n *   return () => {\r\n *     document.body.removeEventListener('click', handler);\r\n *   };\r\n * });\r\n * ```\r\n *\r\n * @param callback - The callback function used to describe the callback logic\r\n *   The callback function is passed an object with the following properties:\r\n *\r\n *   - `receive` - A function that can send events back to the parent actor; the\r\n *       listener is then called whenever events are received by the callback\r\n *       actor\r\n *   - `sendBack` - A function that can send events back to the parent actor\r\n *   - `input` - Data that was provided to the callback actor\r\n *   - `self` - The parent actor of the callback actor\r\n *   - `system` - The actor system to which the callback actor belongs The callback\r\n *       function can (optionally) return a cleanup function, which is called\r\n *       when the actor is stopped.\r\n *\r\n * @returns Callback logic\r\n * @see {@link CallbackLogicFunction} for more information about the callback function and its object argument\r\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\r\n */\nfunction fromCallback(callback) {\n  const logic = {\n    config: callback,\n    start: (state, actorScope) => {\n      const {\n        self,\n        system,\n        emit\n      } = actorScope;\n      const callbackState = {\n        receivers: undefined,\n        dispose: undefined\n      };\n      instanceStates.set(self, callbackState);\n      callbackState.dispose = callback({\n        input: state.input,\n        system,\n        self,\n        sendBack: event => {\n          if (self.getSnapshot().status === 'stopped') {\n            return;\n          }\n          if (self._parent) {\n            system._relay(self, self._parent, event);\n          }\n        },\n        receive: listener => {\n          callbackState.receivers ??= new Set();\n          callbackState.receivers.add(listener);\n        },\n        emit\n      });\n    },\n    transition: (state, event, actorScope) => {\n      const callbackState = instanceStates.get(actorScope.self);\n      if (event.type === XSTATE_STOP) {\n        state = {\n          ...state,\n          status: 'stopped',\n          error: undefined\n        };\n        callbackState.dispose?.();\n        return state;\n      }\n      callbackState.receivers?.forEach(receiver => receiver(event));\n      return state;\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        input\n      };\n    },\n    getPersistedSnapshot: snapshot => snapshot,\n    restoreSnapshot: snapshot => snapshot\n  };\n  return logic;\n}\nconst XSTATE_OBSERVABLE_NEXT = 'xstate.observable.next';\nconst XSTATE_OBSERVABLE_ERROR = 'xstate.observable.error';\nconst XSTATE_OBSERVABLE_COMPLETE = 'xstate.observable.complete';\n\n/**\r\n * Represents an actor created by `fromObservable` or `fromEventObservable`.\r\n *\r\n * The type of `self` within the actor's logic.\r\n *\r\n * @example\r\n *\r\n * ```ts\r\n * import { fromObservable, createActor } from 'xstate';\r\n * import { interval } from 'rxjs';\r\n *\r\n * // The type of the value observed by the actor's logic.\r\n * type Context = number;\r\n * // The actor's input.\r\n * type Input = { period?: number };\r\n *\r\n * // Actor logic that observes a number incremented every `input.period`\r\n * // milliseconds (default: 1_000).\r\n * const logic = fromObservable<Context, Input>(({ input, self }) => {\r\n *   self;\r\n *   // ^? ObservableActorRef<Event, Input>\r\n *\r\n *   return interval(input.period ?? 1_000);\r\n * });\r\n *\r\n * const actor = createActor(logic, { input: { period: 2_000 } });\r\n * //    ^? ObservableActorRef<Event, Input>\r\n * ```\r\n *\r\n * @see {@link fromObservable}\r\n * @see {@link fromEventObservable}\r\n */\n\n/**\r\n * Observable actor logic is described by an observable stream of values. Actors\r\n * created from observable logic (“observable actors”) can:\r\n *\r\n * - Emit snapshots of the observable’s emitted value\r\n *\r\n * The observable’s emitted value is used as its observable actor’s `context`.\r\n *\r\n * Sending events to observable actors will have no effect.\r\n *\r\n * @example\r\n *\r\n * ```ts\r\n * import { fromObservable, createActor } from 'xstate';\r\n * import { interval } from 'rxjs';\r\n *\r\n * const logic = fromObservable((obj) => interval(1000));\r\n *\r\n * const actor = createActor(logic);\r\n *\r\n * actor.subscribe((snapshot) => {\r\n *   console.log(snapshot.context);\r\n * });\r\n *\r\n * actor.start();\r\n * // At every second:\r\n * // Logs 0\r\n * // Logs 1\r\n * // Logs 2\r\n * // ...\r\n * ```\r\n *\r\n * @param observableCreator A function that creates an observable. It receives\r\n *   one argument, an object with the following properties:\r\n *\r\n *   - `input` - Data that was provided to the observable actor\r\n *   - `self` - The parent actor\r\n *   - `system` - The actor system to which the observable actor belongs\r\n *\r\n *   It should return a {@link Subscribable}, which is compatible with an RxJS\r\n *   Observable, although RxJS is not required to create them.\r\n * @see {@link https://rxjs.dev} for documentation on RxJS Observable and observable creators.\r\n * @see {@link Subscribable} interface in XState, which is based on and compatible with RxJS Observable.\r\n */\nfunction fromObservable(observableCreator) {\n  // TODO: add event types\n  const logic = {\n    config: observableCreator,\n    transition: (snapshot, event) => {\n      if (snapshot.status !== 'active') {\n        return snapshot;\n      }\n      switch (event.type) {\n        case XSTATE_OBSERVABLE_NEXT:\n          {\n            const newSnapshot = {\n              ...snapshot,\n              context: event.data\n            };\n            return newSnapshot;\n          }\n        case XSTATE_OBSERVABLE_ERROR:\n          return {\n            ...snapshot,\n            status: 'error',\n            error: event.data,\n            input: undefined,\n            _subscription: undefined\n          };\n        case XSTATE_OBSERVABLE_COMPLETE:\n          return {\n            ...snapshot,\n            status: 'done',\n            input: undefined,\n            _subscription: undefined\n          };\n        case XSTATE_STOP:\n          snapshot._subscription.unsubscribe();\n          return {\n            ...snapshot,\n            status: 'stopped',\n            input: undefined,\n            _subscription: undefined\n          };\n        default:\n          return snapshot;\n      }\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        context: undefined,\n        input,\n        _subscription: undefined\n      };\n    },\n    start: (state, {\n      self,\n      system,\n      emit\n    }) => {\n      if (state.status === 'done') {\n        // Do not restart a completed observable\n        return;\n      }\n      state._subscription = observableCreator({\n        input: state.input,\n        system,\n        self,\n        emit\n      }).subscribe({\n        next: value => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_NEXT,\n            data: value\n          });\n        },\n        error: err => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_ERROR,\n            data: err\n          });\n        },\n        complete: () => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_COMPLETE\n          });\n        }\n      });\n    },\n    getPersistedSnapshot: ({\n      _subscription,\n      ...state\n    }) => state,\n    restoreSnapshot: state => ({\n      ...state,\n      _subscription: undefined\n    })\n  };\n  return logic;\n}\n\n/**\r\n * Creates event observable logic that listens to an observable that delivers\r\n * event objects.\r\n *\r\n * Event observable actor logic is described by an observable stream of\r\n * {@link https://stately.ai/docs/transitions#event-objects | event objects}.\r\n * Actors created from event observable logic (“event observable actors”) can:\r\n *\r\n * - Implicitly send events to its parent actor\r\n * - Emit snapshots of its emitted event objects\r\n *\r\n * Sending events to event observable actors will have no effect.\r\n *\r\n * @example\r\n *\r\n * ```ts\r\n * import {\r\n *   fromEventObservable,\r\n *   Subscribable,\r\n *   EventObject,\r\n *   createMachine,\r\n *   createActor\r\n * } from 'xstate';\r\n * import { fromEvent } from 'rxjs';\r\n *\r\n * const mouseClickLogic = fromEventObservable(\r\n *   () => fromEvent(document.body, 'click') as Subscribable<EventObject>\r\n * );\r\n *\r\n * const canvasMachine = createMachine({\r\n *   invoke: {\r\n *     // Will send mouse `click` events to the canvas actor\r\n *     src: mouseClickLogic\r\n *   }\r\n * });\r\n *\r\n * const canvasActor = createActor(canvasMachine);\r\n * canvasActor.start();\r\n * ```\r\n *\r\n * @param lazyObservable A function that creates an observable that delivers\r\n *   event objects. It receives one argument, an object with the following\r\n *   properties:\r\n *\r\n *   - `input` - Data that was provided to the event observable actor\r\n *   - `self` - The parent actor\r\n *   - `system` - The actor system to which the event observable actor belongs.\r\n *\r\n *   It should return a {@link Subscribable}, which is compatible with an RxJS\r\n *   Observable, although RxJS is not required to create them.\r\n */\nfunction fromEventObservable(lazyObservable) {\n  // TODO: event types\n  const logic = {\n    config: lazyObservable,\n    transition: (state, event) => {\n      if (state.status !== 'active') {\n        return state;\n      }\n      switch (event.type) {\n        case XSTATE_OBSERVABLE_ERROR:\n          return {\n            ...state,\n            status: 'error',\n            error: event.data,\n            input: undefined,\n            _subscription: undefined\n          };\n        case XSTATE_OBSERVABLE_COMPLETE:\n          return {\n            ...state,\n            status: 'done',\n            input: undefined,\n            _subscription: undefined\n          };\n        case XSTATE_STOP:\n          state._subscription.unsubscribe();\n          return {\n            ...state,\n            status: 'stopped',\n            input: undefined,\n            _subscription: undefined\n          };\n        default:\n          return state;\n      }\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        context: undefined,\n        input,\n        _subscription: undefined\n      };\n    },\n    start: (state, {\n      self,\n      system,\n      emit\n    }) => {\n      if (state.status === 'done') {\n        // Do not restart a completed observable\n        return;\n      }\n      state._subscription = lazyObservable({\n        input: state.input,\n        system,\n        self,\n        emit\n      }).subscribe({\n        next: value => {\n          if (self._parent) {\n            system._relay(self, self._parent, value);\n          }\n        },\n        error: err => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_ERROR,\n            data: err\n          });\n        },\n        complete: () => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_COMPLETE\n          });\n        }\n      });\n    },\n    getPersistedSnapshot: ({\n      _subscription,\n      ...snapshot\n    }) => snapshot,\n    restoreSnapshot: snapshot => ({\n      ...snapshot,\n      _subscription: undefined\n    })\n  };\n  return logic;\n}\nconst XSTATE_PROMISE_RESOLVE = 'xstate.promise.resolve';\nconst XSTATE_PROMISE_REJECT = 'xstate.promise.reject';\n\n/**\r\n * Represents an actor created by `fromPromise`.\r\n *\r\n * The type of `self` within the actor's logic.\r\n *\r\n * @example\r\n *\r\n * ```ts\r\n * import { fromPromise, createActor } from 'xstate';\r\n *\r\n * // The actor's resolved output\r\n * type Output = string;\r\n * // The actor's input.\r\n * type Input = { message: string };\r\n *\r\n * // Actor logic that fetches the url of an image of a cat saying `input.message`.\r\n * const logic = fromPromise<Output, Input>(async ({ input, self }) => {\r\n *   self;\r\n *   // ^? PromiseActorRef<Output, Input>\r\n *\r\n *   const data = await fetch(\r\n *     `https://cataas.com/cat/says/${input.message}`\r\n *   );\r\n *   const url = await data.json();\r\n *   return url;\r\n * });\r\n *\r\n * const actor = createActor(logic, { input: { message: 'hello world' } });\r\n * //    ^? PromiseActorRef<Output, Input>\r\n * ```\r\n *\r\n * @see {@link fromPromise}\r\n */\n\nconst controllerMap = new WeakMap();\n\n/**\r\n * An actor logic creator which returns promise logic as defined by an async\r\n * process that resolves or rejects after some time.\r\n *\r\n * Actors created from promise actor logic (“promise actors”) can:\r\n *\r\n * - Emit the resolved value of the promise\r\n * - Output the resolved value of the promise\r\n *\r\n * Sending events to promise actors will have no effect.\r\n *\r\n * @example\r\n *\r\n * ```ts\r\n * const promiseLogic = fromPromise(async () => {\r\n *   const result = await fetch('https://example.com/...').then((data) =>\r\n *     data.json()\r\n *   );\r\n *\r\n *   return result;\r\n * });\r\n *\r\n * const promiseActor = createActor(promiseLogic);\r\n * promiseActor.subscribe((snapshot) => {\r\n *   console.log(snapshot);\r\n * });\r\n * promiseActor.start();\r\n * // => {\r\n * //   output: undefined,\r\n * //   status: 'active'\r\n * //   ...\r\n * // }\r\n *\r\n * // After promise resolves\r\n * // => {\r\n * //   output: { ... },\r\n * //   status: 'done',\r\n * //   ...\r\n * // }\r\n * ```\r\n *\r\n * @param promiseCreator A function which returns a Promise, and accepts an\r\n *   object with the following properties:\r\n *\r\n *   - `input` - Data that was provided to the promise actor\r\n *   - `self` - The parent actor of the promise actor\r\n *   - `system` - The actor system to which the promise actor belongs\r\n *\r\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\r\n */\nfunction fromPromise(promiseCreator) {\n  const logic = {\n    config: promiseCreator,\n    transition: (state, event, scope) => {\n      if (state.status !== 'active') {\n        return state;\n      }\n      switch (event.type) {\n        case XSTATE_PROMISE_RESOLVE:\n          {\n            const resolvedValue = event.data;\n            return {\n              ...state,\n              status: 'done',\n              output: resolvedValue,\n              input: undefined\n            };\n          }\n        case XSTATE_PROMISE_REJECT:\n          return {\n            ...state,\n            status: 'error',\n            error: event.data,\n            input: undefined\n          };\n        case XSTATE_STOP:\n          {\n            controllerMap.get(scope.self)?.abort();\n            return {\n              ...state,\n              status: 'stopped',\n              input: undefined\n            };\n          }\n        default:\n          return state;\n      }\n    },\n    start: (state, {\n      self,\n      system,\n      emit\n    }) => {\n      // TODO: determine how to allow customizing this so that promises\n      // can be restarted if necessary\n      if (state.status !== 'active') {\n        return;\n      }\n      const controller = new AbortController();\n      controllerMap.set(self, controller);\n      const resolvedPromise = Promise.resolve(promiseCreator({\n        input: state.input,\n        system,\n        self,\n        signal: controller.signal,\n        emit\n      }));\n      resolvedPromise.then(response => {\n        if (self.getSnapshot().status !== 'active') {\n          return;\n        }\n        controllerMap.delete(self);\n        system._relay(self, self, {\n          type: XSTATE_PROMISE_RESOLVE,\n          data: response\n        });\n      }, errorData => {\n        if (self.getSnapshot().status !== 'active') {\n          return;\n        }\n        controllerMap.delete(self);\n        system._relay(self, self, {\n          type: XSTATE_PROMISE_REJECT,\n          data: errorData\n        });\n      });\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        input\n      };\n    },\n    getPersistedSnapshot: snapshot => snapshot,\n    restoreSnapshot: snapshot => snapshot\n  };\n  return logic;\n}\nconst emptyLogic = fromTransition(_ => undefined, undefined);\nfunction createEmptyActor() {\n  return createActor(emptyLogic);\n}\nexport { createEmptyActor, fromCallback, fromEventObservable, fromObservable, fromPromise, fromTransition };","map":{"version":3,"names":["X","XSTATE_STOP","A","createActor","fromTransition","transition","initialContext","config","snapshot","event","actorScope","context","getInitialSnapshot","_","input","status","output","undefined","error","getPersistedSnapshot","restoreSnapshot","instanceStates","WeakMap","fromCallback","callback","logic","start","state","self","system","emit","callbackState","receivers","dispose","set","sendBack","getSnapshot","_parent","_relay","receive","listener","Set","add","get","type","forEach","receiver","XSTATE_OBSERVABLE_NEXT","XSTATE_OBSERVABLE_ERROR","XSTATE_OBSERVABLE_COMPLETE","fromObservable","observableCreator","newSnapshot","data","_subscription","unsubscribe","subscribe","next","value","err","complete","fromEventObservable","lazyObservable","XSTATE_PROMISE_RESOLVE","XSTATE_PROMISE_REJECT","controllerMap","fromPromise","promiseCreator","scope","resolvedValue","abort","controller","AbortController","resolvedPromise","Promise","resolve","signal","then","response","delete","errorData","emptyLogic","createEmptyActor"],"sources":["C:/Users/kenne/OneDrive/Documents/GitHub/Night-Kitchen-Projects/Night-Kitchen-Projects/node_modules/xstate/actors/dist/xstate-actors.development.esm.js"],"sourcesContent":["import { X as XSTATE_STOP, A as createActor } from '../../dist/raise-5ea71f04.development.esm.js';\r\nimport '../../dev/dist/xstate-dev.development.esm.js';\r\n\r\n/**\r\n * Represents an actor created by `fromTransition`.\r\n *\r\n * The type of `self` within the actor's logic.\r\n *\r\n * @example\r\n *\r\n * ```ts\r\n * import {\r\n *   fromTransition,\r\n *   createActor,\r\n *   type AnyActorSystem\r\n * } from 'xstate';\r\n *\r\n * //* The actor's stored context.\r\n * type Context = {\r\n *   // The current count.\r\n *   count: number;\r\n *   // The amount to increase `count` by.\r\n *   step: number;\r\n * };\r\n * // The events the actor receives.\r\n * type Event = { type: 'increment' };\r\n * // The actor's input.\r\n * type Input = { step?: number };\r\n *\r\n * // Actor logic that increments `count` by `step` when it receives an event of\r\n * // type `increment`.\r\n * const logic = fromTransition<Context, Event, AnyActorSystem, Input>(\r\n *   (state, event, actorScope) => {\r\n *     actorScope.self;\r\n *     //         ^? TransitionActorRef<Context, Event>\r\n *\r\n *     if (event.type === 'increment') {\r\n *       return {\r\n *         ...state,\r\n *         count: state.count + state.step\r\n *       };\r\n *     }\r\n *     return state;\r\n *   },\r\n *   ({ input, self }) => {\r\n *     self;\r\n *     // ^? TransitionActorRef<Context, Event>\r\n *\r\n *     return {\r\n *       count: 0,\r\n *       step: input.step ?? 1\r\n *     };\r\n *   }\r\n * );\r\n *\r\n * const actor = createActor(logic, { input: { step: 10 } });\r\n * //    ^? TransitionActorRef<Context, Event>\r\n * ```\r\n *\r\n * @see {@link fromTransition}\r\n */\r\n\r\n/**\r\n * Returns actor logic given a transition function and its initial state.\r\n *\r\n * A “transition function” is a function that takes the current `state` and\r\n * received `event` object as arguments, and returns the next state, similar to\r\n * a reducer.\r\n *\r\n * Actors created from transition logic (“transition actors”) can:\r\n *\r\n * - Receive events\r\n * - Emit snapshots of its state\r\n *\r\n * The transition function’s `state` is used as its transition actor’s\r\n * `context`.\r\n *\r\n * Note that the \"state\" for a transition function is provided by the initial\r\n * state argument, and is not the same as the State object of an actor or a\r\n * state within a machine configuration.\r\n *\r\n * @example\r\n *\r\n * ```ts\r\n * const transitionLogic = fromTransition(\r\n *   (state, event) => {\r\n *     if (event.type === 'increment') {\r\n *       return {\r\n *         ...state,\r\n *         count: state.count + 1\r\n *       };\r\n *     }\r\n *     return state;\r\n *   },\r\n *   { count: 0 }\r\n * );\r\n *\r\n * const transitionActor = createActor(transitionLogic);\r\n * transitionActor.subscribe((snapshot) => {\r\n *   console.log(snapshot);\r\n * });\r\n * transitionActor.start();\r\n * // => {\r\n * //   status: 'active',\r\n * //   context: { count: 0 },\r\n * //   ...\r\n * // }\r\n *\r\n * transitionActor.send({ type: 'increment' });\r\n * // => {\r\n * //   status: 'active',\r\n * //   context: { count: 1 },\r\n * //   ...\r\n * // }\r\n * ```\r\n *\r\n * @param transition The transition function used to describe the transition\r\n *   logic. It should return the next state given the current state and event.\r\n *   It receives the following arguments:\r\n *\r\n *   - `state` - the current state.\r\n *   - `event` - the received event.\r\n *   - `actorScope` - the actor scope object, with properties like `self` and\r\n *       `system`.\r\n *\r\n * @param initialContext The initial state of the transition function, either an\r\n *   object representing the state, or a function which returns a state object.\r\n *   If a function, it will receive as its only argument an object with the\r\n *   following properties:\r\n *\r\n *   - `input` - the `input` provided to its parent transition actor.\r\n *   - `self` - a reference to its parent transition actor.\r\n *\r\n * @returns Actor logic\r\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\r\n */\r\nfunction fromTransition(transition, initialContext) {\r\n  return {\r\n    config: transition,\r\n    transition: (snapshot, event, actorScope) => {\r\n      return {\r\n        ...snapshot,\r\n        context: transition(snapshot.context, event, actorScope)\r\n      };\r\n    },\r\n    getInitialSnapshot: (_, input) => {\r\n      return {\r\n        status: 'active',\r\n        output: undefined,\r\n        error: undefined,\r\n        context: typeof initialContext === 'function' ? initialContext({\r\n          input\r\n        }) : initialContext\r\n      };\r\n    },\r\n    getPersistedSnapshot: snapshot => snapshot,\r\n    restoreSnapshot: snapshot => snapshot\r\n  };\r\n}\r\n\r\nconst instanceStates = /* #__PURE__ */new WeakMap();\r\n\r\n/**\r\n * Represents an actor created by `fromCallback`.\r\n *\r\n * The type of `self` within the actor's logic.\r\n *\r\n * @example\r\n *\r\n * ```ts\r\n * import { fromCallback, createActor } from 'xstate';\r\n *\r\n * // The events the actor receives.\r\n * type Event = { type: 'someEvent' };\r\n * // The actor's input.\r\n * type Input = { name: string };\r\n *\r\n * // Actor logic that logs whenever it receives an event of type `someEvent`.\r\n * const logic = fromCallback<Event, Input>(({ self, input, receive }) => {\r\n *   self;\r\n *   // ^? CallbackActorRef<Event, Input>\r\n *\r\n *   receive((event) => {\r\n *     if (event.type === 'someEvent') {\r\n *       console.log(`${input.name}: received \"someEvent\" event`);\r\n *       // logs 'myActor: received \"someEvent\" event'\r\n *     }\r\n *   });\r\n * });\r\n *\r\n * const actor = createActor(logic, { input: { name: 'myActor' } });\r\n * //    ^? CallbackActorRef<Event, Input>\r\n * ```\r\n *\r\n * @see {@link fromCallback}\r\n */\r\n\r\n/**\r\n * An actor logic creator which returns callback logic as defined by a callback\r\n * function.\r\n *\r\n * @remarks\r\n * Useful for subscription-based or other free-form logic that can send events\r\n * back to the parent actor.\r\n *\r\n * Actors created from callback logic (“callback actors”) can:\r\n *\r\n * - Receive events via the `receive` function\r\n * - Send events to the parent actor via the `sendBack` function\r\n *\r\n * Callback actors are a bit different from other actors in that they:\r\n *\r\n * - Do not work with `onDone`\r\n * - Do not produce a snapshot using `.getSnapshot()`\r\n * - Do not emit values when used with `.subscribe()`\r\n * - Can not be stopped with `.stop()`\r\n *\r\n * @example\r\n *\r\n * ```typescript\r\n * const callbackLogic = fromCallback(({ sendBack, receive }) => {\r\n *   let lockStatus = 'unlocked';\r\n *\r\n *   const handler = (event) => {\r\n *     if (lockStatus === 'locked') {\r\n *       return;\r\n *     }\r\n *     sendBack(event);\r\n *   };\r\n *\r\n *   receive((event) => {\r\n *     if (event.type === 'lock') {\r\n *       lockStatus = 'locked';\r\n *     } else if (event.type === 'unlock') {\r\n *       lockStatus = 'unlocked';\r\n *     }\r\n *   });\r\n *\r\n *   document.body.addEventListener('click', handler);\r\n *\r\n *   return () => {\r\n *     document.body.removeEventListener('click', handler);\r\n *   };\r\n * });\r\n * ```\r\n *\r\n * @param callback - The callback function used to describe the callback logic\r\n *   The callback function is passed an object with the following properties:\r\n *\r\n *   - `receive` - A function that can send events back to the parent actor; the\r\n *       listener is then called whenever events are received by the callback\r\n *       actor\r\n *   - `sendBack` - A function that can send events back to the parent actor\r\n *   - `input` - Data that was provided to the callback actor\r\n *   - `self` - The parent actor of the callback actor\r\n *   - `system` - The actor system to which the callback actor belongs The callback\r\n *       function can (optionally) return a cleanup function, which is called\r\n *       when the actor is stopped.\r\n *\r\n * @returns Callback logic\r\n * @see {@link CallbackLogicFunction} for more information about the callback function and its object argument\r\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\r\n */\r\nfunction fromCallback(callback) {\r\n  const logic = {\r\n    config: callback,\r\n    start: (state, actorScope) => {\r\n      const {\r\n        self,\r\n        system,\r\n        emit\r\n      } = actorScope;\r\n      const callbackState = {\r\n        receivers: undefined,\r\n        dispose: undefined\r\n      };\r\n      instanceStates.set(self, callbackState);\r\n      callbackState.dispose = callback({\r\n        input: state.input,\r\n        system,\r\n        self,\r\n        sendBack: event => {\r\n          if (self.getSnapshot().status === 'stopped') {\r\n            return;\r\n          }\r\n          if (self._parent) {\r\n            system._relay(self, self._parent, event);\r\n          }\r\n        },\r\n        receive: listener => {\r\n          callbackState.receivers ??= new Set();\r\n          callbackState.receivers.add(listener);\r\n        },\r\n        emit\r\n      });\r\n    },\r\n    transition: (state, event, actorScope) => {\r\n      const callbackState = instanceStates.get(actorScope.self);\r\n      if (event.type === XSTATE_STOP) {\r\n        state = {\r\n          ...state,\r\n          status: 'stopped',\r\n          error: undefined\r\n        };\r\n        callbackState.dispose?.();\r\n        return state;\r\n      }\r\n      callbackState.receivers?.forEach(receiver => receiver(event));\r\n      return state;\r\n    },\r\n    getInitialSnapshot: (_, input) => {\r\n      return {\r\n        status: 'active',\r\n        output: undefined,\r\n        error: undefined,\r\n        input\r\n      };\r\n    },\r\n    getPersistedSnapshot: snapshot => snapshot,\r\n    restoreSnapshot: snapshot => snapshot\r\n  };\r\n  return logic;\r\n}\r\n\r\nconst XSTATE_OBSERVABLE_NEXT = 'xstate.observable.next';\r\nconst XSTATE_OBSERVABLE_ERROR = 'xstate.observable.error';\r\nconst XSTATE_OBSERVABLE_COMPLETE = 'xstate.observable.complete';\r\n\r\n/**\r\n * Represents an actor created by `fromObservable` or `fromEventObservable`.\r\n *\r\n * The type of `self` within the actor's logic.\r\n *\r\n * @example\r\n *\r\n * ```ts\r\n * import { fromObservable, createActor } from 'xstate';\r\n * import { interval } from 'rxjs';\r\n *\r\n * // The type of the value observed by the actor's logic.\r\n * type Context = number;\r\n * // The actor's input.\r\n * type Input = { period?: number };\r\n *\r\n * // Actor logic that observes a number incremented every `input.period`\r\n * // milliseconds (default: 1_000).\r\n * const logic = fromObservable<Context, Input>(({ input, self }) => {\r\n *   self;\r\n *   // ^? ObservableActorRef<Event, Input>\r\n *\r\n *   return interval(input.period ?? 1_000);\r\n * });\r\n *\r\n * const actor = createActor(logic, { input: { period: 2_000 } });\r\n * //    ^? ObservableActorRef<Event, Input>\r\n * ```\r\n *\r\n * @see {@link fromObservable}\r\n * @see {@link fromEventObservable}\r\n */\r\n\r\n/**\r\n * Observable actor logic is described by an observable stream of values. Actors\r\n * created from observable logic (“observable actors”) can:\r\n *\r\n * - Emit snapshots of the observable’s emitted value\r\n *\r\n * The observable’s emitted value is used as its observable actor’s `context`.\r\n *\r\n * Sending events to observable actors will have no effect.\r\n *\r\n * @example\r\n *\r\n * ```ts\r\n * import { fromObservable, createActor } from 'xstate';\r\n * import { interval } from 'rxjs';\r\n *\r\n * const logic = fromObservable((obj) => interval(1000));\r\n *\r\n * const actor = createActor(logic);\r\n *\r\n * actor.subscribe((snapshot) => {\r\n *   console.log(snapshot.context);\r\n * });\r\n *\r\n * actor.start();\r\n * // At every second:\r\n * // Logs 0\r\n * // Logs 1\r\n * // Logs 2\r\n * // ...\r\n * ```\r\n *\r\n * @param observableCreator A function that creates an observable. It receives\r\n *   one argument, an object with the following properties:\r\n *\r\n *   - `input` - Data that was provided to the observable actor\r\n *   - `self` - The parent actor\r\n *   - `system` - The actor system to which the observable actor belongs\r\n *\r\n *   It should return a {@link Subscribable}, which is compatible with an RxJS\r\n *   Observable, although RxJS is not required to create them.\r\n * @see {@link https://rxjs.dev} for documentation on RxJS Observable and observable creators.\r\n * @see {@link Subscribable} interface in XState, which is based on and compatible with RxJS Observable.\r\n */\r\nfunction fromObservable(observableCreator) {\r\n  // TODO: add event types\r\n  const logic = {\r\n    config: observableCreator,\r\n    transition: (snapshot, event) => {\r\n      if (snapshot.status !== 'active') {\r\n        return snapshot;\r\n      }\r\n      switch (event.type) {\r\n        case XSTATE_OBSERVABLE_NEXT:\r\n          {\r\n            const newSnapshot = {\r\n              ...snapshot,\r\n              context: event.data\r\n            };\r\n            return newSnapshot;\r\n          }\r\n        case XSTATE_OBSERVABLE_ERROR:\r\n          return {\r\n            ...snapshot,\r\n            status: 'error',\r\n            error: event.data,\r\n            input: undefined,\r\n            _subscription: undefined\r\n          };\r\n        case XSTATE_OBSERVABLE_COMPLETE:\r\n          return {\r\n            ...snapshot,\r\n            status: 'done',\r\n            input: undefined,\r\n            _subscription: undefined\r\n          };\r\n        case XSTATE_STOP:\r\n          snapshot._subscription.unsubscribe();\r\n          return {\r\n            ...snapshot,\r\n            status: 'stopped',\r\n            input: undefined,\r\n            _subscription: undefined\r\n          };\r\n        default:\r\n          return snapshot;\r\n      }\r\n    },\r\n    getInitialSnapshot: (_, input) => {\r\n      return {\r\n        status: 'active',\r\n        output: undefined,\r\n        error: undefined,\r\n        context: undefined,\r\n        input,\r\n        _subscription: undefined\r\n      };\r\n    },\r\n    start: (state, {\r\n      self,\r\n      system,\r\n      emit\r\n    }) => {\r\n      if (state.status === 'done') {\r\n        // Do not restart a completed observable\r\n        return;\r\n      }\r\n      state._subscription = observableCreator({\r\n        input: state.input,\r\n        system,\r\n        self,\r\n        emit\r\n      }).subscribe({\r\n        next: value => {\r\n          system._relay(self, self, {\r\n            type: XSTATE_OBSERVABLE_NEXT,\r\n            data: value\r\n          });\r\n        },\r\n        error: err => {\r\n          system._relay(self, self, {\r\n            type: XSTATE_OBSERVABLE_ERROR,\r\n            data: err\r\n          });\r\n        },\r\n        complete: () => {\r\n          system._relay(self, self, {\r\n            type: XSTATE_OBSERVABLE_COMPLETE\r\n          });\r\n        }\r\n      });\r\n    },\r\n    getPersistedSnapshot: ({\r\n      _subscription,\r\n      ...state\r\n    }) => state,\r\n    restoreSnapshot: state => ({\r\n      ...state,\r\n      _subscription: undefined\r\n    })\r\n  };\r\n  return logic;\r\n}\r\n\r\n/**\r\n * Creates event observable logic that listens to an observable that delivers\r\n * event objects.\r\n *\r\n * Event observable actor logic is described by an observable stream of\r\n * {@link https://stately.ai/docs/transitions#event-objects | event objects}.\r\n * Actors created from event observable logic (“event observable actors”) can:\r\n *\r\n * - Implicitly send events to its parent actor\r\n * - Emit snapshots of its emitted event objects\r\n *\r\n * Sending events to event observable actors will have no effect.\r\n *\r\n * @example\r\n *\r\n * ```ts\r\n * import {\r\n *   fromEventObservable,\r\n *   Subscribable,\r\n *   EventObject,\r\n *   createMachine,\r\n *   createActor\r\n * } from 'xstate';\r\n * import { fromEvent } from 'rxjs';\r\n *\r\n * const mouseClickLogic = fromEventObservable(\r\n *   () => fromEvent(document.body, 'click') as Subscribable<EventObject>\r\n * );\r\n *\r\n * const canvasMachine = createMachine({\r\n *   invoke: {\r\n *     // Will send mouse `click` events to the canvas actor\r\n *     src: mouseClickLogic\r\n *   }\r\n * });\r\n *\r\n * const canvasActor = createActor(canvasMachine);\r\n * canvasActor.start();\r\n * ```\r\n *\r\n * @param lazyObservable A function that creates an observable that delivers\r\n *   event objects. It receives one argument, an object with the following\r\n *   properties:\r\n *\r\n *   - `input` - Data that was provided to the event observable actor\r\n *   - `self` - The parent actor\r\n *   - `system` - The actor system to which the event observable actor belongs.\r\n *\r\n *   It should return a {@link Subscribable}, which is compatible with an RxJS\r\n *   Observable, although RxJS is not required to create them.\r\n */\r\nfunction fromEventObservable(lazyObservable) {\r\n  // TODO: event types\r\n  const logic = {\r\n    config: lazyObservable,\r\n    transition: (state, event) => {\r\n      if (state.status !== 'active') {\r\n        return state;\r\n      }\r\n      switch (event.type) {\r\n        case XSTATE_OBSERVABLE_ERROR:\r\n          return {\r\n            ...state,\r\n            status: 'error',\r\n            error: event.data,\r\n            input: undefined,\r\n            _subscription: undefined\r\n          };\r\n        case XSTATE_OBSERVABLE_COMPLETE:\r\n          return {\r\n            ...state,\r\n            status: 'done',\r\n            input: undefined,\r\n            _subscription: undefined\r\n          };\r\n        case XSTATE_STOP:\r\n          state._subscription.unsubscribe();\r\n          return {\r\n            ...state,\r\n            status: 'stopped',\r\n            input: undefined,\r\n            _subscription: undefined\r\n          };\r\n        default:\r\n          return state;\r\n      }\r\n    },\r\n    getInitialSnapshot: (_, input) => {\r\n      return {\r\n        status: 'active',\r\n        output: undefined,\r\n        error: undefined,\r\n        context: undefined,\r\n        input,\r\n        _subscription: undefined\r\n      };\r\n    },\r\n    start: (state, {\r\n      self,\r\n      system,\r\n      emit\r\n    }) => {\r\n      if (state.status === 'done') {\r\n        // Do not restart a completed observable\r\n        return;\r\n      }\r\n      state._subscription = lazyObservable({\r\n        input: state.input,\r\n        system,\r\n        self,\r\n        emit\r\n      }).subscribe({\r\n        next: value => {\r\n          if (self._parent) {\r\n            system._relay(self, self._parent, value);\r\n          }\r\n        },\r\n        error: err => {\r\n          system._relay(self, self, {\r\n            type: XSTATE_OBSERVABLE_ERROR,\r\n            data: err\r\n          });\r\n        },\r\n        complete: () => {\r\n          system._relay(self, self, {\r\n            type: XSTATE_OBSERVABLE_COMPLETE\r\n          });\r\n        }\r\n      });\r\n    },\r\n    getPersistedSnapshot: ({\r\n      _subscription,\r\n      ...snapshot\r\n    }) => snapshot,\r\n    restoreSnapshot: snapshot => ({\r\n      ...snapshot,\r\n      _subscription: undefined\r\n    })\r\n  };\r\n  return logic;\r\n}\r\n\r\nconst XSTATE_PROMISE_RESOLVE = 'xstate.promise.resolve';\r\nconst XSTATE_PROMISE_REJECT = 'xstate.promise.reject';\r\n\r\n/**\r\n * Represents an actor created by `fromPromise`.\r\n *\r\n * The type of `self` within the actor's logic.\r\n *\r\n * @example\r\n *\r\n * ```ts\r\n * import { fromPromise, createActor } from 'xstate';\r\n *\r\n * // The actor's resolved output\r\n * type Output = string;\r\n * // The actor's input.\r\n * type Input = { message: string };\r\n *\r\n * // Actor logic that fetches the url of an image of a cat saying `input.message`.\r\n * const logic = fromPromise<Output, Input>(async ({ input, self }) => {\r\n *   self;\r\n *   // ^? PromiseActorRef<Output, Input>\r\n *\r\n *   const data = await fetch(\r\n *     `https://cataas.com/cat/says/${input.message}`\r\n *   );\r\n *   const url = await data.json();\r\n *   return url;\r\n * });\r\n *\r\n * const actor = createActor(logic, { input: { message: 'hello world' } });\r\n * //    ^? PromiseActorRef<Output, Input>\r\n * ```\r\n *\r\n * @see {@link fromPromise}\r\n */\r\n\r\nconst controllerMap = new WeakMap();\r\n\r\n/**\r\n * An actor logic creator which returns promise logic as defined by an async\r\n * process that resolves or rejects after some time.\r\n *\r\n * Actors created from promise actor logic (“promise actors”) can:\r\n *\r\n * - Emit the resolved value of the promise\r\n * - Output the resolved value of the promise\r\n *\r\n * Sending events to promise actors will have no effect.\r\n *\r\n * @example\r\n *\r\n * ```ts\r\n * const promiseLogic = fromPromise(async () => {\r\n *   const result = await fetch('https://example.com/...').then((data) =>\r\n *     data.json()\r\n *   );\r\n *\r\n *   return result;\r\n * });\r\n *\r\n * const promiseActor = createActor(promiseLogic);\r\n * promiseActor.subscribe((snapshot) => {\r\n *   console.log(snapshot);\r\n * });\r\n * promiseActor.start();\r\n * // => {\r\n * //   output: undefined,\r\n * //   status: 'active'\r\n * //   ...\r\n * // }\r\n *\r\n * // After promise resolves\r\n * // => {\r\n * //   output: { ... },\r\n * //   status: 'done',\r\n * //   ...\r\n * // }\r\n * ```\r\n *\r\n * @param promiseCreator A function which returns a Promise, and accepts an\r\n *   object with the following properties:\r\n *\r\n *   - `input` - Data that was provided to the promise actor\r\n *   - `self` - The parent actor of the promise actor\r\n *   - `system` - The actor system to which the promise actor belongs\r\n *\r\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\r\n */\r\nfunction fromPromise(promiseCreator) {\r\n  const logic = {\r\n    config: promiseCreator,\r\n    transition: (state, event, scope) => {\r\n      if (state.status !== 'active') {\r\n        return state;\r\n      }\r\n      switch (event.type) {\r\n        case XSTATE_PROMISE_RESOLVE:\r\n          {\r\n            const resolvedValue = event.data;\r\n            return {\r\n              ...state,\r\n              status: 'done',\r\n              output: resolvedValue,\r\n              input: undefined\r\n            };\r\n          }\r\n        case XSTATE_PROMISE_REJECT:\r\n          return {\r\n            ...state,\r\n            status: 'error',\r\n            error: event.data,\r\n            input: undefined\r\n          };\r\n        case XSTATE_STOP:\r\n          {\r\n            controllerMap.get(scope.self)?.abort();\r\n            return {\r\n              ...state,\r\n              status: 'stopped',\r\n              input: undefined\r\n            };\r\n          }\r\n        default:\r\n          return state;\r\n      }\r\n    },\r\n    start: (state, {\r\n      self,\r\n      system,\r\n      emit\r\n    }) => {\r\n      // TODO: determine how to allow customizing this so that promises\r\n      // can be restarted if necessary\r\n      if (state.status !== 'active') {\r\n        return;\r\n      }\r\n      const controller = new AbortController();\r\n      controllerMap.set(self, controller);\r\n      const resolvedPromise = Promise.resolve(promiseCreator({\r\n        input: state.input,\r\n        system,\r\n        self,\r\n        signal: controller.signal,\r\n        emit\r\n      }));\r\n      resolvedPromise.then(response => {\r\n        if (self.getSnapshot().status !== 'active') {\r\n          return;\r\n        }\r\n        controllerMap.delete(self);\r\n        system._relay(self, self, {\r\n          type: XSTATE_PROMISE_RESOLVE,\r\n          data: response\r\n        });\r\n      }, errorData => {\r\n        if (self.getSnapshot().status !== 'active') {\r\n          return;\r\n        }\r\n        controllerMap.delete(self);\r\n        system._relay(self, self, {\r\n          type: XSTATE_PROMISE_REJECT,\r\n          data: errorData\r\n        });\r\n      });\r\n    },\r\n    getInitialSnapshot: (_, input) => {\r\n      return {\r\n        status: 'active',\r\n        output: undefined,\r\n        error: undefined,\r\n        input\r\n      };\r\n    },\r\n    getPersistedSnapshot: snapshot => snapshot,\r\n    restoreSnapshot: snapshot => snapshot\r\n  };\r\n  return logic;\r\n}\r\n\r\nconst emptyLogic = fromTransition(_ => undefined, undefined);\r\nfunction createEmptyActor() {\r\n  return createActor(emptyLogic);\r\n}\r\n\r\nexport { createEmptyActor, fromCallback, fromEventObservable, fromObservable, fromPromise, fromTransition };\r\n"],"mappings":"AAAA,SAASA,CAAC,IAAIC,WAAW,EAAEC,CAAC,IAAIC,WAAW,QAAQ,8CAA8C;AACjG,OAAO,8CAA8C;;AAErD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,cAAcA,CAACC,UAAU,EAAEC,cAAc,EAAE;EAClD,OAAO;IACLC,MAAM,EAAEF,UAAU;IAClBA,UAAU,EAAEA,CAACG,QAAQ,EAAEC,KAAK,EAAEC,UAAU,KAAK;MAC3C,OAAO;QACL,GAAGF,QAAQ;QACXG,OAAO,EAAEN,UAAU,CAACG,QAAQ,CAACG,OAAO,EAAEF,KAAK,EAAEC,UAAU;MACzD,CAAC;IACH,CAAC;IACDE,kBAAkB,EAAEA,CAACC,CAAC,EAAEC,KAAK,KAAK;MAChC,OAAO;QACLC,MAAM,EAAE,QAAQ;QAChBC,MAAM,EAAEC,SAAS;QACjBC,KAAK,EAAED,SAAS;QAChBN,OAAO,EAAE,OAAOL,cAAc,KAAK,UAAU,GAAGA,cAAc,CAAC;UAC7DQ;QACF,CAAC,CAAC,GAAGR;MACP,CAAC;IACH,CAAC;IACDa,oBAAoB,EAAEX,QAAQ,IAAIA,QAAQ;IAC1CY,eAAe,EAAEZ,QAAQ,IAAIA;EAC/B,CAAC;AACH;AAEA,MAAMa,cAAc,GAAG,eAAe,IAAIC,OAAO,CAAC,CAAC;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,YAAYA,CAACC,QAAQ,EAAE;EAC9B,MAAMC,KAAK,GAAG;IACZlB,MAAM,EAAEiB,QAAQ;IAChBE,KAAK,EAAEA,CAACC,KAAK,EAAEjB,UAAU,KAAK;MAC5B,MAAM;QACJkB,IAAI;QACJC,MAAM;QACNC;MACF,CAAC,GAAGpB,UAAU;MACd,MAAMqB,aAAa,GAAG;QACpBC,SAAS,EAAEf,SAAS;QACpBgB,OAAO,EAAEhB;MACX,CAAC;MACDI,cAAc,CAACa,GAAG,CAACN,IAAI,EAAEG,aAAa,CAAC;MACvCA,aAAa,CAACE,OAAO,GAAGT,QAAQ,CAAC;QAC/BV,KAAK,EAAEa,KAAK,CAACb,KAAK;QAClBe,MAAM;QACND,IAAI;QACJO,QAAQ,EAAE1B,KAAK,IAAI;UACjB,IAAImB,IAAI,CAACQ,WAAW,CAAC,CAAC,CAACrB,MAAM,KAAK,SAAS,EAAE;YAC3C;UACF;UACA,IAAIa,IAAI,CAACS,OAAO,EAAE;YAChBR,MAAM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hBR,MAAM,CAACS,MAAM,CAACV,IAAI,EAAEA,IAAI,CAACS,OAAO,EAAEqB,KAAK,CAAC;UAC1C;QACF,CAAC;QACDxC,KAAK,EAAEyC,GAAG,IAAI;UACZ9B,MAAM,CAACS,MAAM,CAACV,IAAI,EAAEA,IAAI,EAAE;YACxBgB,IAAI,EAAEI,uBAAuB;YAC7BK,IAAI,EAAEM;UACR,CAAC,CAAC;QACJ,CAAC;QACDC,QAAQ,EAAEA,CAAA,KAAM;UACd/B,MAAM,CAACS,MAAM,CAACV,IAAI,EAAEA,IAAI,EAAE;YACxBgB,IAAI,EAAEK;UACR,CAAC,CAAC;QACJ;MACF,CAAC,CAAC;IACJ,CAAC;IACD9B,oBAAoB,EAAEA,CAAC;MACrBmC,aAAa;MACb,GAAG9C;IACL,CAAC,KAAKA,QAAQ;IACdY,eAAe,EAAEZ,QAAQ,KAAK;MAC5B,GAAGA,QAAQ;MACX8C,aAAa,EAAErC;IACjB,CAAC;EACH,CAAC;EACD,OAAOQ,KAAK;AACd;AAEA,MAAMsC,sBAAsB,GAAG,wBAAwB;AACvD,MAAMC,qBAAqB,GAAG,uBAAuB;;AAErD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMC,aAAa,GAAG,IAAI3C,OAAO,CAAC,CAAC;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS4C,WAAWA,CAACC,cAAc,EAAE;EACnC,MAAM1C,KAAK,GAAG;IACZlB,MAAM,EAAE4D,cAAc;IACtB9D,UAAU,EAAEA,CAACsB,KAAK,EAAElB,KAAK,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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}