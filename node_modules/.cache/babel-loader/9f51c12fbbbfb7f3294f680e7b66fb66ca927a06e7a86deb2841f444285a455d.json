{"ast":null,"code":"import { T as ProcessingStatus, z as resolveReferencedActor, A as createActor, U as cloneMachineSnapshot, V as executingCustomAction, W as XSTATE_ERROR, Y as createErrorActorEvent, e as evaluateGuard, M as cancel, O as raise, P as spawnChild, R as stopChild } from './raise-5ea71f04.development.esm.js';\nfunction createSpawner(actorScope, {\n  machine,\n  context\n}, event, spawnedChildren) {\n  const spawn = (src, options = {}) => {\n    const {\n      systemId,\n      input\n    } = options;\n    if (typeof src === 'string') {\n      const logic = resolveReferencedActor(machine, src);\n      if (!logic) {\n        throw new Error(`Actor logic '${src}' not implemented in machine '${machine.id}'`);\n      }\n      const actorRef = createActor(logic, {\n        id: options.id,\n        parent: actorScope.self,\n        syncSnapshot: options.syncSnapshot,\n        input: typeof input === 'function' ? input({\n          context,\n          event,\n          self: actorScope.self\n        }) : input,\n        src,\n        systemId\n      });\n      spawnedChildren[actorRef.id] = actorRef;\n      return actorRef;\n    } else {\n      const actorRef = createActor(src, {\n        id: options.id,\n        parent: actorScope.self,\n        syncSnapshot: options.syncSnapshot,\n        input: options.input,\n        src,\n        systemId\n      });\n      return actorRef;\n    }\n  };\n  return (src, options) => {\n    const actorRef = spawn(src, options); // TODO: fix types\n    spawnedChildren[actorRef.id] = actorRef;\n    actorScope.defer(() => {\n      if (actorRef._processingStatus === ProcessingStatus.Stopped) {\n        return;\n      }\n      actorRef.start();\n    });\n    return actorRef;\n  };\n}\nfunction resolveAssign(actorScope, snapshot, actionArgs, actionParams, {\n  assignment\n}) {\n  if (!snapshot.context) {\n    throw new Error('Cannot assign to undefined `context`. Ensure that `context` is defined in the machine config.');\n  }\n  const spawnedChildren = {};\n  const assignArgs = {\n    context: snapshot.context,\n    event: actionArgs.event,\n    spawn: createSpawner(actorScope, snapshot, actionArgs.event, spawnedChildren),\n    self: actorScope.self,\n    system: actorScope.system\n  };\n  let partialUpdate = {};\n  if (typeof assignment === 'function') {\n    partialUpdate = assignment(assignArgs, actionParams);\n  } else {\n    for (const key of Object.keys(assignment)) {\n      const propAssignment = assignment[key];\n      partialUpdate[key] = typeof propAssignment === 'function' ? propAssignment(assignArgs, actionParams) : propAssignment;\n    }\n  }\n  const updatedContext = Object.assign({}, snapshot.context, partialUpdate);\n  return [cloneMachineSnapshot(snapshot, {\n    context: updatedContext,\n    children: Object.keys(spawnedChildren).length ? {\n      ...snapshot.children,\n      ...spawnedChildren\n    } : snapshot.children\n  })];\n}\n/**\r\n * Updates the current context of the machine.\r\n *\r\n * @example\r\n *\r\n * ```ts\r\n * import { createMachine, assign } from 'xstate';\r\n *\r\n * const countMachine = createMachine({\r\n *   context: {\r\n *     count: 0,\r\n *     message: ''\r\n *   },\r\n *   on: {\r\n *     inc: {\r\n *       actions: assign({\r\n *         count: ({ context }) => context.count + 1\r\n *       })\r\n *     },\r\n *     updateMessage: {\r\n *       actions: assign(({ context, event }) => {\r\n *         return {\r\n *           message: event.message.trim()\r\n *         };\r\n *       })\r\n *     }\r\n *   }\r\n * });\r\n * ```\r\n *\r\n * @param assignment An object that represents the partial context to update, or\r\n *   a function that returns an object that represents the partial context to\r\n *   update.\r\n */\nfunction assign(assignment) {\n  if (executingCustomAction) {\n    console.warn('Custom actions should not call `assign()` directly, as it is not imperative. See https://stately.ai/docs/actions#built-in-actions for more details.');\n  }\n  function assign(args, params) {\n    {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n  assign.type = 'xstate.assign';\n  assign.assignment = assignment;\n  assign.resolve = resolveAssign;\n  return assign;\n}\nfunction resolveEmit(_, snapshot, args, actionParams, {\n  event: eventOrExpr\n}) {\n  if (typeof eventOrExpr === 'string') {\n    throw new Error(`Only event objects may be used with emit; use emit({ type: \"${eventOrExpr}\" }) instead`);\n  }\n  const resolvedEvent = typeof eventOrExpr === 'function' ? eventOrExpr(args, actionParams) : eventOrExpr;\n  return [snapshot, {\n    event: resolvedEvent\n  }];\n}\nfunction executeEmit(actorScope, {\n  event\n}) {\n  actorScope.defer(() => actorScope.emit(event));\n}\n/**\r\n * Emits an event to event handlers registered on the actor via `actor.on(event,\r\n * handler)`.\r\n *\r\n * @example\r\n *\r\n * ```ts\r\n * import { emit } from 'xstate';\r\n *\r\n * const machine = createMachine({\r\n *   // ...\r\n *   on: {\r\n *     something: {\r\n *       actions: emit({\r\n *         type: 'emitted',\r\n *         some: 'data'\r\n *       })\r\n *     }\r\n *   }\r\n *   // ...\r\n * });\r\n *\r\n * const actor = createActor(machine).start();\r\n *\r\n * actor.on('emitted', (event) => {\r\n *   console.log(event);\r\n * });\r\n *\r\n * actor.send({ type: 'something' });\r\n * // logs:\r\n * // {\r\n * //   type: 'emitted',\r\n * //   some: 'data'\r\n * // }\r\n * ```\r\n */\nfunction emit(/** The event to emit, or an expression that returns an event to emit. */\neventOrExpr) {\n  if (executingCustomAction) {\n    console.warn('Custom actions should not call `emit()` directly, as it is not imperative. See https://stately.ai/docs/actions#built-in-actions for more details.');\n  }\n  function emit(args, params) {\n    {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n  emit.type = 'xstate.emit';\n  emit.event = eventOrExpr;\n  emit.resolve = resolveEmit;\n  emit.execute = executeEmit;\n  return emit;\n}\n\n/**\r\n * @remarks\r\n * `T | unknown` reduces to `unknown` and that can be problematic when it comes\r\n * to contextual typing. It especially is a problem when the union has a\r\n * function member, like here:\r\n *\r\n * ```ts\r\n * declare function test(\r\n *   cbOrVal: ((arg: number) => unknown) | unknown\r\n * ): void;\r\n * test((arg) => {}); // oops, implicit any\r\n * ```\r\n *\r\n * This type can be used to avoid this problem. This union represents the same\r\n * value space as `unknown`.\r\n */\n\n// https://github.com/microsoft/TypeScript/issues/23182#issuecomment-379091887\n\n// @TODO: Replace with native `NoInfer` when TS issue gets fixed:\n// https://github.com/microsoft/TypeScript/pull/57673\n\n/** @deprecated Use the built-in `NoInfer` type instead */\n\n/** The full definition of an event, with a string `type`. */\n\n/**\r\n * The string or object representing the state value relative to the parent\r\n * state node.\r\n *\r\n * @remarks\r\n * - For a child atomic state node, this is a string, e.g., `\"pending\"`.\r\n * - For complex state nodes, this is an object, e.g., `{ success:\r\n *   \"someChildState\" }`.\r\n */\n\n// TODO: remove once TS fixes this type-widening issue\n\n/** @deprecated Use `AnyMachineSnapshot` instead */\n\n// TODO: possibly refactor this somehow, use even a simpler type, and maybe even make `machine.options` private or something\n/** @ignore */\n\nlet SpecialTargets = /*#__PURE__*/function (SpecialTargets) {\n  SpecialTargets[\"Parent\"] = \"#_parent\";\n  SpecialTargets[\"Internal\"] = \"#_internal\";\n  return SpecialTargets;\n}({});\n\n/** @deprecated Use `AnyActor` instead. */\n\n// Based on RxJS types\n\n// TODO: in v6, this should only accept AnyActorLogic, like ActorRefFromLogic\n\n/** @deprecated Use `Actor<T>` instead. */\n\n/**\r\n * Represents logic which can be used by an actor.\r\n *\r\n * @template TSnapshot - The type of the snapshot.\r\n * @template TEvent - The type of the event object.\r\n * @template TInput - The type of the input.\r\n * @template TSystem - The type of the actor system.\r\n */\n\n/** @deprecated */\n\nfunction resolveSendTo(actorScope, snapshot, args, actionParams, {\n  to,\n  event: eventOrExpr,\n  id,\n  delay\n}, extra) {\n  const delaysMap = snapshot.machine.implementations.delays;\n  if (typeof eventOrExpr === 'string') {\n    throw new Error(`Only event objects may be used with sendTo; use sendTo({ type: \"${eventOrExpr}\" }) instead`);\n  }\n  const resolvedEvent = typeof eventOrExpr === 'function' ? eventOrExpr(args, actionParams) : eventOrExpr;\n  let resolvedDelay;\n  if (typeof delay === 'string') {\n    const configDelay = delaysMap && delaysMap[delay];\n    resolvedDelay = typeof configDelay === 'function' ? configDelay(args, actionParams) : configDelay;\n  } else {\n    resolvedDelay = typeof delay === 'function' ? delay(args, actionParams) : delay;\n  }\n  const resolvedTarget = typeof to === 'function' ? to(args, actionParams) : to;\n  let targetActorRef;\n  if (typeof resolvedTarget === 'string') {\n    if (resolvedTarget === SpecialTargets.Parent) {\n      targetActorRef = actorScope.self._parent;\n    } else if (resolvedTarget === SpecialTargets.Internal) {\n      targetActorRef = actorScope.self;\n    } else if (resolvedTarget.startsWith('#_')) {\n      // SCXML compatibility: https://www.w3.org/TR/scxml/#SCXMLEventProcessor\n      // #_invokeid. If the target is the special term '#_invokeid', where invokeid is the invokeid of an SCXML session that the sending session has created by <invoke>, the Processor must add the event to the external queue of that session.\n      targetActorRef = snapshot.children[resolvedTarget.slice(2)];\n    } else {\n      targetActorRef = extra.deferredActorIds?.includes(resolvedTarget) ? resolvedTarget : snapshot.children[resolvedTarget];\n    }\n    if (!targetActorRef) {\n      throw new Error(`Unable to send event to actor '${resolvedTarget}' from machine '${snapshot.machine.id}'.`);\n    }\n  } else {\n    targetActorRef = resolvedTarget || actorScope.self;\n  }\n  return [snapshot, {\n    to: targetActorRef,\n    event: resolvedEvent,\n    id,\n    delay: resolvedDelay\n  }];\n}\nfunction retryResolveSendTo(_, snapshot, params) {\n  if (typeof params.to === 'string') {\n    params.to = snapshot.children[params.to];\n  }\n}\nfunction executeSendTo(actorScope, params) {\n  // this forms an outgoing events queue\n  // thanks to that the recipient actors are able to read the *updated* snapshot value of the sender\n  actorScope.defer(() => {\n    const {\n      to,\n      event,\n      delay,\n      id\n    } = params;\n    if (typeof delay === 'number') {\n      actorScope.system.scheduler.schedule(actorScope.self, to, event, delay, id);\n      return;\n    }\n    actorScope.system._relay(actorScope.self,\n    // at this point, in a deferred task, it should already be mutated by retryResolveSendTo\n    // if it initially started as a string\n    to, event.type === XSTATE_ERROR ? createErrorActorEvent(actorScope.self.id, event.data) : event);\n  });\n}\n/**\r\n * Sends an event to an actor.\r\n *\r\n * @param actor The `ActorRef` to send the event to.\r\n * @param event The event to send, or an expression that evaluates to the event\r\n *   to send\r\n * @param options Send action options\r\n *\r\n *   - `id` - The unique send event identifier (used with `cancel()`).\r\n *   - `delay` - The number of milliseconds to delay the sending of the event.\r\n */\nfunction sendTo(to, eventOrExpr, options) {\n  if (executingCustomAction) {\n    console.warn('Custom actions should not call `raise()` directly, as it is not imperative. See https://stately.ai/docs/actions#built-in-actions for more details.');\n  }\n  function sendTo(args, params) {\n    {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n  sendTo.type = 'xsnapshot.sendTo';\n  sendTo.to = to;\n  sendTo.event = eventOrExpr;\n  sendTo.id = options?.id;\n  sendTo.delay = options?.delay;\n  sendTo.resolve = resolveSendTo;\n  sendTo.retryResolve = retryResolveSendTo;\n  sendTo.execute = executeSendTo;\n  return sendTo;\n}\n\n/**\r\n * Sends an event to this machine's parent.\r\n *\r\n * @param event The event to send to the parent machine.\r\n * @param options Options to pass into the send event.\r\n */\nfunction sendParent(event, options) {\n  return sendTo(SpecialTargets.Parent, event, options);\n}\n/**\r\n * Forwards (sends) an event to the `target` actor.\r\n *\r\n * @param target The target actor to forward the event to.\r\n * @param options Options to pass into the send action creator.\r\n */\nfunction forwardTo(target, options) {\n  if (!target || typeof target === 'function') {\n    const originalTarget = target;\n    target = (...args) => {\n      const resolvedTarget = typeof originalTarget === 'function' ? originalTarget(...args) : originalTarget;\n      if (!resolvedTarget) {\n        throw new Error(`Attempted to forward event to undefined actor. This risks an infinite loop in the sender.`);\n      }\n      return resolvedTarget;\n    };\n  }\n  return sendTo(target, ({\n    event\n  }) => event, options);\n}\nfunction resolveEnqueueActions(actorScope, snapshot, args, actionParams, {\n  collect\n}) {\n  const actions = [];\n  const enqueue = function enqueue(action) {\n    actions.push(action);\n  };\n  enqueue.assign = (...args) => {\n    actions.push(assign(...args));\n  };\n  enqueue.cancel = (...args) => {\n    actions.push(cancel(...args));\n  };\n  enqueue.raise = (...args) => {\n    // for some reason it fails to infer `TDelay` from `...args` here and picks its default (`never`)\n    // then it fails to typecheck that because `...args` use `string` in place of `TDelay`\n    actions.push(raise(...args));\n  };\n  enqueue.sendTo = (...args) => {\n    // for some reason it fails to infer `TDelay` from `...args` here and picks its default (`never`)\n    // then it fails to typecheck that because `...args` use `string` in place of `TDelay\n    actions.push(sendTo(...args));\n  };\n  enqueue.sendParent = (...args) => {\n    actions.push(sendParent(...args));\n  };\n  enqueue.spawnChild = (...args) => {\n    actions.push(spawnChild(...args));\n  };\n  enqueue.stopChild = (...args) => {\n    actions.push(stopChild(...args));\n  };\n  enqueue.emit = (...args) => {\n    actions.push(emit(...args));\n  };\n  collect({\n    context: args.context,\n    event: args.event,\n    enqueue,\n    check: guard => evaluateGuard(guard, snapshot.context, args.event, snapshot),\n    self: actorScope.self,\n    system: actorScope.system\n  }, actionParams);\n  return [snapshot, undefined, actions];\n}\n/**\r\n * Creates an action object that will execute actions that are queued by the\r\n * `enqueue(action)` function.\r\n *\r\n * @example\r\n *\r\n * ```ts\r\n * import { createMachine, enqueueActions } from 'xstate';\r\n *\r\n * const machine = createMachine({\r\n *   entry: enqueueActions(({ enqueue, check }) => {\r\n *     enqueue.assign({ count: 0 });\r\n *\r\n *     if (check('someGuard')) {\r\n *       enqueue.assign({ count: 1 });\r\n *     }\r\n *\r\n *     enqueue('someAction');\r\n *   })\r\n * });\r\n * ```\r\n */\nfunction enqueueActions(collect) {\n  function enqueueActions(args, params) {\n    {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n  enqueueActions.type = 'xstate.enqueueActions';\n  enqueueActions.collect = collect;\n  enqueueActions.resolve = resolveEnqueueActions;\n  return enqueueActions;\n}\nfunction resolveLog(_, snapshot, actionArgs, actionParams, {\n  value,\n  label\n}) {\n  return [snapshot, {\n    value: typeof value === 'function' ? value(actionArgs, actionParams) : value,\n    label\n  }];\n}\nfunction executeLog({\n  logger\n}, {\n  value,\n  label\n}) {\n  if (label) {\n    logger(label, value);\n  } else {\n    logger(value);\n  }\n}\n/**\r\n * @param expr The expression function to evaluate which will be logged. Takes\r\n *   in 2 arguments:\r\n *\r\n *   - `ctx` - the current state context\r\n *   - `event` - the event that caused this action to be executed.\r\n *\r\n * @param label The label to give to the logged expression.\r\n */\nfunction log(value = ({\n  context,\n  event\n}) => ({\n  context,\n  event\n}), label) {\n  function log(args, params) {\n    {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n  log.type = 'xstate.log';\n  log.value = value;\n  log.label = label;\n  log.resolve = resolveLog;\n  log.execute = executeLog;\n  return log;\n}\nexport { SpecialTargets as S, assign as a, enqueueActions as b, sendTo as c, emit as e, forwardTo as f, log as l, sendParent as s };","map":{"version":3,"names":["T","ProcessingStatus","z","resolveReferencedActor","A","createActor","U","cloneMachineSnapshot","V","executingCustomAction","W","XSTATE_ERROR","Y","createErrorActorEvent","e","evaluateGuard","M","cancel","O","raise","P","spawnChild","R","stopChild","createSpawner","actorScope","machine","context","event","spawnedChildren","spawn","src","options","systemId","input","logic","Error","id","actorRef","parent","self","syncSnapshot","defer","_processingStatus","Stopped","start","resolveAssign","snapshot","actionArgs","actionParams","assignment","assignArgs","system","partialUpdate","key","Object","keys","propAssignment","updatedContext","assign","children","length","console","warn","args","params","type","resolve","resolveEmit","_","eventOrExpr","resolvedEvent","executeEmit","emit","execute","SpecialTargets","resolveSendTo","to","delay","extra","delaysMap","implementations","delays","resolvedDelay","configDelay","resolvedTarget","targetActorRef","Parent","_parent","Internal","startsWith","slice","deferredActorIds","includes","retryResolveSendTo","executeSendTo","scheduler","schedule","_relay","data","sendTo","retryResolve","sendParent","forwardTo","target","originalTarget","resolveEnqueueActions","collect","actions","enqueue","action","push","check","guard","undefined","enqueueActions","resolveLog","value","label","executeLog","logger","log","S","a","b","c","f","l","s"],"sources":["C:/Users/kenne/OneDrive/Documents/GitHub/Night-Kitchen-Projects/Night-Kitchen-Projects/node_modules/xstate/dist/log-38475d87.development.esm.js"],"sourcesContent":["import { T as ProcessingStatus, z as resolveReferencedActor, A as createActor, U as cloneMachineSnapshot, V as executingCustomAction, W as XSTATE_ERROR, Y as createErrorActorEvent, e as evaluateGuard, M as cancel, O as raise, P as spawnChild, R as stopChild } from './raise-5ea71f04.development.esm.js';\r\n\r\nfunction createSpawner(actorScope, {\r\n  machine,\r\n  context\r\n}, event, spawnedChildren) {\r\n  const spawn = (src, options = {}) => {\r\n    const {\r\n      systemId,\r\n      input\r\n    } = options;\r\n    if (typeof src === 'string') {\r\n      const logic = resolveReferencedActor(machine, src);\r\n      if (!logic) {\r\n        throw new Error(`Actor logic '${src}' not implemented in machine '${machine.id}'`);\r\n      }\r\n      const actorRef = createActor(logic, {\r\n        id: options.id,\r\n        parent: actorScope.self,\r\n        syncSnapshot: options.syncSnapshot,\r\n        input: typeof input === 'function' ? input({\r\n          context,\r\n          event,\r\n          self: actorScope.self\r\n        }) : input,\r\n        src,\r\n        systemId\r\n      });\r\n      spawnedChildren[actorRef.id] = actorRef;\r\n      return actorRef;\r\n    } else {\r\n      const actorRef = createActor(src, {\r\n        id: options.id,\r\n        parent: actorScope.self,\r\n        syncSnapshot: options.syncSnapshot,\r\n        input: options.input,\r\n        src,\r\n        systemId\r\n      });\r\n      return actorRef;\r\n    }\r\n  };\r\n  return (src, options) => {\r\n    const actorRef = spawn(src, options); // TODO: fix types\r\n    spawnedChildren[actorRef.id] = actorRef;\r\n    actorScope.defer(() => {\r\n      if (actorRef._processingStatus === ProcessingStatus.Stopped) {\r\n        return;\r\n      }\r\n      actorRef.start();\r\n    });\r\n    return actorRef;\r\n  };\r\n}\r\n\r\nfunction resolveAssign(actorScope, snapshot, actionArgs, actionParams, {\r\n  assignment\r\n}) {\r\n  if (!snapshot.context) {\r\n    throw new Error('Cannot assign to undefined `context`. Ensure that `context` is defined in the machine config.');\r\n  }\r\n  const spawnedChildren = {};\r\n  const assignArgs = {\r\n    context: snapshot.context,\r\n    event: actionArgs.event,\r\n    spawn: createSpawner(actorScope, snapshot, actionArgs.event, spawnedChildren),\r\n    self: actorScope.self,\r\n    system: actorScope.system\r\n  };\r\n  let partialUpdate = {};\r\n  if (typeof assignment === 'function') {\r\n    partialUpdate = assignment(assignArgs, actionParams);\r\n  } else {\r\n    for (const key of Object.keys(assignment)) {\r\n      const propAssignment = assignment[key];\r\n      partialUpdate[key] = typeof propAssignment === 'function' ? propAssignment(assignArgs, actionParams) : propAssignment;\r\n    }\r\n  }\r\n  const updatedContext = Object.assign({}, snapshot.context, partialUpdate);\r\n  return [cloneMachineSnapshot(snapshot, {\r\n    context: updatedContext,\r\n    children: Object.keys(spawnedChildren).length ? {\r\n      ...snapshot.children,\r\n      ...spawnedChildren\r\n    } : snapshot.children\r\n  })];\r\n}\r\n/**\r\n * Updates the current context of the machine.\r\n *\r\n * @example\r\n *\r\n * ```ts\r\n * import { createMachine, assign } from 'xstate';\r\n *\r\n * const countMachine = createMachine({\r\n *   context: {\r\n *     count: 0,\r\n *     message: ''\r\n *   },\r\n *   on: {\r\n *     inc: {\r\n *       actions: assign({\r\n *         count: ({ context }) => context.count + 1\r\n *       })\r\n *     },\r\n *     updateMessage: {\r\n *       actions: assign(({ context, event }) => {\r\n *         return {\r\n *           message: event.message.trim()\r\n *         };\r\n *       })\r\n *     }\r\n *   }\r\n * });\r\n * ```\r\n *\r\n * @param assignment An object that represents the partial context to update, or\r\n *   a function that returns an object that represents the partial context to\r\n *   update.\r\n */\r\nfunction assign(assignment) {\r\n  if (executingCustomAction) {\r\n    console.warn('Custom actions should not call `assign()` directly, as it is not imperative. See https://stately.ai/docs/actions#built-in-actions for more details.');\r\n  }\r\n  function assign(args, params) {\r\n    {\r\n      throw new Error(`This isn't supposed to be called`);\r\n    }\r\n  }\r\n  assign.type = 'xstate.assign';\r\n  assign.assignment = assignment;\r\n  assign.resolve = resolveAssign;\r\n  return assign;\r\n}\r\n\r\nfunction resolveEmit(_, snapshot, args, actionParams, {\r\n  event: eventOrExpr\r\n}) {\r\n  if (typeof eventOrExpr === 'string') {\r\n    throw new Error(`Only event objects may be used with emit; use emit({ type: \"${eventOrExpr}\" }) instead`);\r\n  }\r\n  const resolvedEvent = typeof eventOrExpr === 'function' ? eventOrExpr(args, actionParams) : eventOrExpr;\r\n  return [snapshot, {\r\n    event: resolvedEvent\r\n  }];\r\n}\r\nfunction executeEmit(actorScope, {\r\n  event\r\n}) {\r\n  actorScope.defer(() => actorScope.emit(event));\r\n}\r\n/**\r\n * Emits an event to event handlers registered on the actor via `actor.on(event,\r\n * handler)`.\r\n *\r\n * @example\r\n *\r\n * ```ts\r\n * import { emit } from 'xstate';\r\n *\r\n * const machine = createMachine({\r\n *   // ...\r\n *   on: {\r\n *     something: {\r\n *       actions: emit({\r\n *         type: 'emitted',\r\n *         some: 'data'\r\n *       })\r\n *     }\r\n *   }\r\n *   // ...\r\n * });\r\n *\r\n * const actor = createActor(machine).start();\r\n *\r\n * actor.on('emitted', (event) => {\r\n *   console.log(event);\r\n * });\r\n *\r\n * actor.send({ type: 'something' });\r\n * // logs:\r\n * // {\r\n * //   type: 'emitted',\r\n * //   some: 'data'\r\n * // }\r\n * ```\r\n */\r\nfunction emit(/** The event to emit, or an expression that returns an event to emit. */\r\neventOrExpr) {\r\n  if (executingCustomAction) {\r\n    console.warn('Custom actions should not call `emit()` directly, as it is not imperative. See https://stately.ai/docs/actions#built-in-actions for more details.');\r\n  }\r\n  function emit(args, params) {\r\n    {\r\n      throw new Error(`This isn't supposed to be called`);\r\n    }\r\n  }\r\n  emit.type = 'xstate.emit';\r\n  emit.event = eventOrExpr;\r\n  emit.resolve = resolveEmit;\r\n  emit.execute = executeEmit;\r\n  return emit;\r\n}\r\n\r\n/**\r\n * @remarks\r\n * `T | unknown` reduces to `unknown` and that can be problematic when it comes\r\n * to contextual typing. It especially is a problem when the union has a\r\n * function member, like here:\r\n *\r\n * ```ts\r\n * declare function test(\r\n *   cbOrVal: ((arg: number) => unknown) | unknown\r\n * ): void;\r\n * test((arg) => {}); // oops, implicit any\r\n * ```\r\n *\r\n * This type can be used to avoid this problem. This union represents the same\r\n * value space as `unknown`.\r\n */\r\n\r\n// https://github.com/microsoft/TypeScript/issues/23182#issuecomment-379091887\r\n\r\n// @TODO: Replace with native `NoInfer` when TS issue gets fixed:\r\n// https://github.com/microsoft/TypeScript/pull/57673\r\n\r\n/** @deprecated Use the built-in `NoInfer` type instead */\r\n\r\n/** The full definition of an event, with a string `type`. */\r\n\r\n/**\r\n * The string or object representing the state value relative to the parent\r\n * state node.\r\n *\r\n * @remarks\r\n * - For a child atomic state node, this is a string, e.g., `\"pending\"`.\r\n * - For complex state nodes, this is an object, e.g., `{ success:\r\n *   \"someChildState\" }`.\r\n */\r\n\r\n// TODO: remove once TS fixes this type-widening issue\r\n\r\n/** @deprecated Use `AnyMachineSnapshot` instead */\r\n\r\n// TODO: possibly refactor this somehow, use even a simpler type, and maybe even make `machine.options` private or something\r\n/** @ignore */\r\n\r\nlet SpecialTargets = /*#__PURE__*/function (SpecialTargets) {\r\n  SpecialTargets[\"Parent\"] = \"#_parent\";\r\n  SpecialTargets[\"Internal\"] = \"#_internal\";\r\n  return SpecialTargets;\r\n}({});\r\n\r\n/** @deprecated Use `AnyActor` instead. */\r\n\r\n// Based on RxJS types\r\n\r\n// TODO: in v6, this should only accept AnyActorLogic, like ActorRefFromLogic\r\n\r\n/** @deprecated Use `Actor<T>` instead. */\r\n\r\n/**\r\n * Represents logic which can be used by an actor.\r\n *\r\n * @template TSnapshot - The type of the snapshot.\r\n * @template TEvent - The type of the event object.\r\n * @template TInput - The type of the input.\r\n * @template TSystem - The type of the actor system.\r\n */\r\n\r\n/** @deprecated */\r\n\r\nfunction resolveSendTo(actorScope, snapshot, args, actionParams, {\r\n  to,\r\n  event: eventOrExpr,\r\n  id,\r\n  delay\r\n}, extra) {\r\n  const delaysMap = snapshot.machine.implementations.delays;\r\n  if (typeof eventOrExpr === 'string') {\r\n    throw new Error(`Only event objects may be used with sendTo; use sendTo({ type: \"${eventOrExpr}\" }) instead`);\r\n  }\r\n  const resolvedEvent = typeof eventOrExpr === 'function' ? eventOrExpr(args, actionParams) : eventOrExpr;\r\n  let resolvedDelay;\r\n  if (typeof delay === 'string') {\r\n    const configDelay = delaysMap && delaysMap[delay];\r\n    resolvedDelay = typeof configDelay === 'function' ? configDelay(args, actionParams) : configDelay;\r\n  } else {\r\n    resolvedDelay = typeof delay === 'function' ? delay(args, actionParams) : delay;\r\n  }\r\n  const resolvedTarget = typeof to === 'function' ? to(args, actionParams) : to;\r\n  let targetActorRef;\r\n  if (typeof resolvedTarget === 'string') {\r\n    if (resolvedTarget === SpecialTargets.Parent) {\r\n      targetActorRef = actorScope.self._parent;\r\n    } else if (resolvedTarget === SpecialTargets.Internal) {\r\n      targetActorRef = actorScope.self;\r\n    } else if (resolvedTarget.startsWith('#_')) {\r\n      // SCXML compatibility: https://www.w3.org/TR/scxml/#SCXMLEventProcessor\r\n      // #_invokeid. If the target is the special term '#_invokeid', where invokeid is the invokeid of an SCXML session that the sending session has created by <invoke>, the Processor must add the event to the external queue of that session.\r\n      targetActorRef = snapshot.children[resolvedTarget.slice(2)];\r\n    } else {\r\n      targetActorRef = extra.deferredActorIds?.includes(resolvedTarget) ? resolvedTarget : snapshot.children[resolvedTarget];\r\n    }\r\n    if (!targetActorRef) {\r\n      throw new Error(`Unable to send event to actor '${resolvedTarget}' from machine '${snapshot.machine.id}'.`);\r\n    }\r\n  } else {\r\n    targetActorRef = resolvedTarget || actorScope.self;\r\n  }\r\n  return [snapshot, {\r\n    to: targetActorRef,\r\n    event: resolvedEvent,\r\n    id,\r\n    delay: resolvedDelay\r\n  }];\r\n}\r\nfunction retryResolveSendTo(_, snapshot, params) {\r\n  if (typeof params.to === 'string') {\r\n    params.to = snapshot.children[params.to];\r\n  }\r\n}\r\nfunction executeSendTo(actorScope, params) {\r\n  // this forms an outgoing events queue\r\n  // thanks to that the recipient actors are able to read the *updated* snapshot value of the sender\r\n  actorScope.defer(() => {\r\n    const {\r\n      to,\r\n      event,\r\n      delay,\r\n      id\r\n    } = params;\r\n    if (typeof delay === 'number') {\r\n      actorScope.system.scheduler.schedule(actorScope.self, to, event, delay, id);\r\n      return;\r\n    }\r\n    actorScope.system._relay(actorScope.self,\r\n    // at this point, in a deferred task, it should already be mutated by retryResolveSendTo\r\n    // if it initially started as a string\r\n    to, event.type === XSTATE_ERROR ? createErrorActorEvent(actorScope.self.id, event.data) : event);\r\n  });\r\n}\r\n/**\r\n * Sends an event to an actor.\r\n *\r\n * @param actor The `ActorRef` to send the event to.\r\n * @param event The event to send, or an expression that evaluates to the event\r\n *   to send\r\n * @param options Send action options\r\n *\r\n *   - `id` - The unique send event identifier (used with `cancel()`).\r\n *   - `delay` - The number of milliseconds to delay the sending of the event.\r\n */\r\nfunction sendTo(to, eventOrExpr, options) {\r\n  if (executingCustomAction) {\r\n    console.warn('Custom actions should not call `raise()` directly, as it is not imperative. See https://stately.ai/docs/actions#built-in-actions for more details.');\r\n  }\r\n  function sendTo(args, params) {\r\n    {\r\n      throw new Error(`This isn't supposed to be called`);\r\n    }\r\n  }\r\n  sendTo.type = 'xsnapshot.sendTo';\r\n  sendTo.to = to;\r\n  sendTo.event = eventOrExpr;\r\n  sendTo.id = options?.id;\r\n  sendTo.delay = options?.delay;\r\n  sendTo.resolve = resolveSendTo;\r\n  sendTo.retryResolve = retryResolveSendTo;\r\n  sendTo.execute = executeSendTo;\r\n  return sendTo;\r\n}\r\n\r\n/**\r\n * Sends an event to this machine's parent.\r\n *\r\n * @param event The event to send to the parent machine.\r\n * @param options Options to pass into the send event.\r\n */\r\nfunction sendParent(event, options) {\r\n  return sendTo(SpecialTargets.Parent, event, options);\r\n}\r\n/**\r\n * Forwards (sends) an event to the `target` actor.\r\n *\r\n * @param target The target actor to forward the event to.\r\n * @param options Options to pass into the send action creator.\r\n */\r\nfunction forwardTo(target, options) {\r\n  if ((!target || typeof target === 'function')) {\r\n    const originalTarget = target;\r\n    target = (...args) => {\r\n      const resolvedTarget = typeof originalTarget === 'function' ? originalTarget(...args) : originalTarget;\r\n      if (!resolvedTarget) {\r\n        throw new Error(`Attempted to forward event to undefined actor. This risks an infinite loop in the sender.`);\r\n      }\r\n      return resolvedTarget;\r\n    };\r\n  }\r\n  return sendTo(target, ({\r\n    event\r\n  }) => event, options);\r\n}\r\n\r\nfunction resolveEnqueueActions(actorScope, snapshot, args, actionParams, {\r\n  collect\r\n}) {\r\n  const actions = [];\r\n  const enqueue = function enqueue(action) {\r\n    actions.push(action);\r\n  };\r\n  enqueue.assign = (...args) => {\r\n    actions.push(assign(...args));\r\n  };\r\n  enqueue.cancel = (...args) => {\r\n    actions.push(cancel(...args));\r\n  };\r\n  enqueue.raise = (...args) => {\r\n    // for some reason it fails to infer `TDelay` from `...args` here and picks its default (`never`)\r\n    // then it fails to typecheck that because `...args` use `string` in place of `TDelay`\r\n    actions.push(raise(...args));\r\n  };\r\n  enqueue.sendTo = (...args) => {\r\n    // for some reason it fails to infer `TDelay` from `...args` here and picks its default (`never`)\r\n    // then it fails to typecheck that because `...args` use `string` in place of `TDelay\r\n    actions.push(sendTo(...args));\r\n  };\r\n  enqueue.sendParent = (...args) => {\r\n    actions.push(sendParent(...args));\r\n  };\r\n  enqueue.spawnChild = (...args) => {\r\n    actions.push(spawnChild(...args));\r\n  };\r\n  enqueue.stopChild = (...args) => {\r\n    actions.push(stopChild(...args));\r\n  };\r\n  enqueue.emit = (...args) => {\r\n    actions.push(emit(...args));\r\n  };\r\n  collect({\r\n    context: args.context,\r\n    event: args.event,\r\n    enqueue,\r\n    check: guard => evaluateGuard(guard, snapshot.context, args.event, snapshot),\r\n    self: actorScope.self,\r\n    system: actorScope.system\r\n  }, actionParams);\r\n  return [snapshot, undefined, actions];\r\n}\r\n/**\r\n * Creates an action object that will execute actions that are queued by the\r\n * `enqueue(action)` function.\r\n *\r\n * @example\r\n *\r\n * ```ts\r\n * import { createMachine, enqueueActions } from 'xstate';\r\n *\r\n * const machine = createMachine({\r\n *   entry: enqueueActions(({ enqueue, check }) => {\r\n *     enqueue.assign({ count: 0 });\r\n *\r\n *     if (check('someGuard')) {\r\n *       enqueue.assign({ count: 1 });\r\n *     }\r\n *\r\n *     enqueue('someAction');\r\n *   })\r\n * });\r\n * ```\r\n */\r\nfunction enqueueActions(collect) {\r\n  function enqueueActions(args, params) {\r\n    {\r\n      throw new Error(`This isn't supposed to be called`);\r\n    }\r\n  }\r\n  enqueueActions.type = 'xstate.enqueueActions';\r\n  enqueueActions.collect = collect;\r\n  enqueueActions.resolve = resolveEnqueueActions;\r\n  return enqueueActions;\r\n}\r\n\r\nfunction resolveLog(_, snapshot, actionArgs, actionParams, {\r\n  value,\r\n  label\r\n}) {\r\n  return [snapshot, {\r\n    value: typeof value === 'function' ? value(actionArgs, actionParams) : value,\r\n    label\r\n  }];\r\n}\r\nfunction executeLog({\r\n  logger\r\n}, {\r\n  value,\r\n  label\r\n}) {\r\n  if (label) {\r\n    logger(label, value);\r\n  } else {\r\n    logger(value);\r\n  }\r\n}\r\n/**\r\n * @param expr The expression function to evaluate which will be logged. Takes\r\n *   in 2 arguments:\r\n *\r\n *   - `ctx` - the current state context\r\n *   - `event` - the event that caused this action to be executed.\r\n *\r\n * @param label The label to give to the logged expression.\r\n */\r\nfunction log(value = ({\r\n  context,\r\n  event\r\n}) => ({\r\n  context,\r\n  event\r\n}), label) {\r\n  function log(args, params) {\r\n    {\r\n      throw new Error(`This isn't supposed to be called`);\r\n    }\r\n  }\r\n  log.type = 'xstate.log';\r\n  log.value = value;\r\n  log.label = label;\r\n  log.resolve = resolveLog;\r\n  log.execute = executeLog;\r\n  return log;\r\n}\r\n\r\nexport { SpecialTargets as S, assign as a, enqueueActions as b, sendTo as c, emit as e, forwardTo as f, log as l, sendParent as s };\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}